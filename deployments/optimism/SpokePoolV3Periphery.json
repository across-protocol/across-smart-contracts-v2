{
  "address": "0x8EB5FF2e23FD7789e59989aDe055A398800E394e",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "bytes4[]",
          "name": "_allowedSelectors",
          "type": "bytes4[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [],
      "name": "ContractInitialized",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidFunctionSelector",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidMsgValue",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSpokePool",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "InvalidSwapToken",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "LeftoverSrcTokens",
      "type": "error"
    },
    {
      "inputs": [],
      "name": "MinimumExpectedInputAmount",
      "type": "error"
    },
    {
      "anonymous": false,
      "inputs": [
        {
          "indexed": false,
          "internalType": "address",
          "name": "exchange",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "swapToken",
          "type": "address"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "acrossInputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "swapTokenAmount",
          "type": "uint256"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "acrossInputAmount",
          "type": "uint256"
        },
        {
          "indexed": true,
          "internalType": "address",
          "name": "acrossOutputToken",
          "type": "address"
        },
        {
          "indexed": false,
          "internalType": "uint256",
          "name": "acrossOutputAmount",
          "type": "uint256"
        }
      ],
      "name": "SwapBeforeBridge",
      "type": "event"
    },
    {
      "inputs": [
        {
          "internalType": "bytes4",
          "name": "",
          "type": "bytes4"
        }
      ],
      "name": "allowedSelectors",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "recipient",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "inputToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "inputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "outputAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "destinationChainId",
          "type": "uint256"
        },
        {
          "internalType": "address",
          "name": "exclusiveRelayer",
          "type": "address"
        },
        {
          "internalType": "uint32",
          "name": "quoteTimestamp",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "fillDeadline",
          "type": "uint32"
        },
        {
          "internalType": "uint32",
          "name": "exclusivityParameter",
          "type": "uint32"
        },
        {
          "internalType": "bytes",
          "name": "message",
          "type": "bytes"
        }
      ],
      "name": "deposit",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20Auth",
          "name": "acrossInputToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "acrossInputAmount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "outputToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "destinationChainid",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "exclusiveRelayer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "quoteTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityParameter",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct SpokePoolV3Periphery.DepositData",
          "name": "depositData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "validAfter",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "validBefore",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "nonce",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "depositWithAuthorization",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20Permit",
          "name": "acrossInputToken",
          "type": "address"
        },
        {
          "internalType": "uint256",
          "name": "acrossInputAmount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "outputToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "destinationChainid",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "exclusiveRelayer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "quoteTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityParameter",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct SpokePoolV3Periphery.DepositData",
          "name": "depositData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "depositWithPermit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "exchange",
      "outputs": [
        {
          "internalType": "address",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract V3SpokePoolInterface",
          "name": "_spokePool",
          "type": "address"
        },
        {
          "internalType": "contract WETH9Interface",
          "name": "_wrappedNativeToken",
          "type": "address"
        },
        {
          "internalType": "address",
          "name": "_exchange",
          "type": "address"
        }
      ],
      "name": "initialize",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes[]",
          "name": "data",
          "type": "bytes[]"
        }
      ],
      "name": "multicall",
      "outputs": [
        {
          "internalType": "bytes[]",
          "name": "results",
          "type": "bytes[]"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "spokePool",
      "outputs": [
        {
          "internalType": "contract V3SpokePoolInterface",
          "name": "",
          "type": "address"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20",
          "name": "swapToken",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "acrossInputToken",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "routerCalldata",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "swapTokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minExpectedInputTokenAmount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "outputToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "destinationChainid",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "exclusiveRelayer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "quoteTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityParameter",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct SpokePoolV3Periphery.DepositData",
          "name": "depositData",
          "type": "tuple"
        }
      ],
      "name": "swapAndBridge",
      "outputs": [],
      "stateMutability": "payable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20Auth",
          "name": "swapToken",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "acrossInputToken",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "routerCalldata",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "swapTokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minExpectedInputTokenAmount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "outputToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "destinationChainid",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "exclusiveRelayer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "quoteTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityParameter",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct SpokePoolV3Periphery.DepositData",
          "name": "depositData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "validAfter",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "validBefore",
          "type": "uint256"
        },
        {
          "internalType": "bytes32",
          "name": "nonce",
          "type": "bytes32"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "swapAndBridgeWithAuthorization",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "contract IERC20Permit",
          "name": "swapToken",
          "type": "address"
        },
        {
          "internalType": "contract IERC20",
          "name": "acrossInputToken",
          "type": "address"
        },
        {
          "internalType": "bytes",
          "name": "routerCalldata",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "swapTokenAmount",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "minExpectedInputTokenAmount",
          "type": "uint256"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "outputToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "outputAmount",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "destinationChainid",
              "type": "uint256"
            },
            {
              "internalType": "address",
              "name": "exclusiveRelayer",
              "type": "address"
            },
            {
              "internalType": "uint32",
              "name": "quoteTimestamp",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "fillDeadline",
              "type": "uint32"
            },
            {
              "internalType": "uint32",
              "name": "exclusivityParameter",
              "type": "uint32"
            },
            {
              "internalType": "bytes",
              "name": "message",
              "type": "bytes"
            }
          ],
          "internalType": "struct SpokePoolV3Periphery.DepositData",
          "name": "depositData",
          "type": "tuple"
        },
        {
          "internalType": "uint256",
          "name": "deadline",
          "type": "uint256"
        },
        {
          "internalType": "uint8",
          "name": "v",
          "type": "uint8"
        },
        {
          "internalType": "bytes32",
          "name": "r",
          "type": "bytes32"
        },
        {
          "internalType": "bytes32",
          "name": "s",
          "type": "bytes32"
        }
      ],
      "name": "swapAndBridgeWithPermit",
      "outputs": [],
      "stateMutability": "nonpayable",
      "type": "function"
    }
  ],
  "transactionHash": "0x8f9beb9b4247ab333bd534ca72ca45162f0d25998287d3ca94e8f2dfa6db5bca",
  "receipt": {
    "to": "0x4e59b44847b379578588920cA78FbF26c0B4956C",
    "from": "0x9A8f92a830A5cB89a3816e3D267CB7791c16b04D",
    "contractAddress": null,
    "transactionIndex": 30,
    "gasUsed": "1823903",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0xd89d1388d559393867680f04a375b99da6f02eca631aa93c6fa9d4e2b7f08e00",
    "transactionHash": "0x8f9beb9b4247ab333bd534ca72ca45162f0d25998287d3ca94e8f2dfa6db5bca",
    "logs": [],
    "blockNumber": 128343804,
    "cumulativeGasUsed": "4706967",
    "status": 1,
    "byzantium": true
  },
  "args": [["0xb858183f", "0x04e45aaf", "0x09b81346", "0x5023b4df", "0x1f0464d1", "0x5ae401dc", "0xac9650d8"]],
  "numDeployments": 1,
  "solcInputHash": "7181ccde94919d66e297cab663ce9775",
  "metadata": "{\"compiler\":{\"version\":\"0.8.23+commit.f704f362\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes4[]\",\"name\":\"_allowedSelectors\",\"type\":\"bytes4[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[],\"name\":\"ContractInitialized\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidFunctionSelector\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidMsgValue\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSpokePool\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"InvalidSwapToken\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"LeftoverSrcTokens\",\"type\":\"error\"},{\"inputs\":[],\"name\":\"MinimumExpectedInputAmount\",\"type\":\"error\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"internalType\":\"address\",\"name\":\"exchange\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"swapToken\",\"type\":\"address\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acrossInputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"swapTokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"acrossInputAmount\",\"type\":\"uint256\"},{\"indexed\":true,\"internalType\":\"address\",\"name\":\"acrossOutputToken\",\"type\":\"address\"},{\"indexed\":false,\"internalType\":\"uint256\",\"name\":\"acrossOutputAmount\",\"type\":\"uint256\"}],\"name\":\"SwapBeforeBridge\",\"type\":\"event\"},{\"inputs\":[{\"internalType\":\"bytes4\",\"name\":\"\",\"type\":\"bytes4\"}],\"name\":\"allowedSelectors\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"inputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"inputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainId\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"name\":\"deposit\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Auth\",\"name\":\"acrossInputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acrossInputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct SpokePoolV3Periphery.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Permit\",\"name\":\"acrossInputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"acrossInputAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct SpokePoolV3Periphery.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"depositWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract V3SpokePoolInterface\",\"name\":\"_spokePool\",\"type\":\"address\"},{\"internalType\":\"contract WETH9Interface\",\"name\":\"_wrappedNativeToken\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_exchange\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes[]\",\"name\":\"data\",\"type\":\"bytes[]\"}],\"name\":\"multicall\",\"outputs\":[{\"internalType\":\"bytes[]\",\"name\":\"results\",\"type\":\"bytes[]\"}],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"spokePool\",\"outputs\":[{\"internalType\":\"contract V3SpokePoolInterface\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20\",\"name\":\"swapToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"acrossInputToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"routerCalldata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedInputTokenAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct SpokePoolV3Periphery.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"}],\"name\":\"swapAndBridge\",\"outputs\":[],\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Auth\",\"name\":\"swapToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"acrossInputToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"routerCalldata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedInputTokenAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct SpokePoolV3Periphery.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"validAfter\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"validBefore\",\"type\":\"uint256\"},{\"internalType\":\"bytes32\",\"name\":\"nonce\",\"type\":\"bytes32\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"swapAndBridgeWithAuthorization\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"contract IERC20Permit\",\"name\":\"swapToken\",\"type\":\"address\"},{\"internalType\":\"contract IERC20\",\"name\":\"acrossInputToken\",\"type\":\"address\"},{\"internalType\":\"bytes\",\"name\":\"routerCalldata\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"swapTokenAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"minExpectedInputTokenAmount\",\"type\":\"uint256\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"outputToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"outputAmount\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"destinationChainid\",\"type\":\"uint256\"},{\"internalType\":\"address\",\"name\":\"exclusiveRelayer\",\"type\":\"address\"},{\"internalType\":\"uint32\",\"name\":\"quoteTimestamp\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"fillDeadline\",\"type\":\"uint32\"},{\"internalType\":\"uint32\",\"name\":\"exclusivityParameter\",\"type\":\"uint32\"},{\"internalType\":\"bytes\",\"name\":\"message\",\"type\":\"bytes\"}],\"internalType\":\"struct SpokePoolV3Periphery.DepositData\",\"name\":\"depositData\",\"type\":\"tuple\"},{\"internalType\":\"uint256\",\"name\":\"deadline\",\"type\":\"uint256\"},{\"internalType\":\"uint8\",\"name\":\"v\",\"type\":\"uint8\"},{\"internalType\":\"bytes32\",\"name\":\"r\",\"type\":\"bytes32\"},{\"internalType\":\"bytes32\",\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"swapAndBridgeWithPermit\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"}],\"devdoc\":{\"custom:security-contact\":\"bugs@across.to\",\"details\":\"Variables which may be immutable are not marked as immutable, nor defined in the constructor, so that this contract may be deployed deterministically.\",\"kind\":\"dev\",\"methods\":{\"constructor\":{\"params\":{\"_allowedSelectors\":\"Function selectors that are allowed to be called on the exchange.\"}},\"deposit(address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)\":{\"details\":\"Protects the caller from losing their ETH (or other native token) by reverting if the SpokePool address they intended to call does not exist on this chain. Because this contract can be deployed at the same address everywhere callers should be protected even if the transaction is submitted to an unintended network. This contract should only be used for native token deposits, as this problem only exists for native tokens.\",\"params\":{\"destinationChainId\":\"Denotes network where user will receive funds from SpokePool by a relayer.\",\"exclusiveRelayer\":\"Address of the relayer who has exclusive rights to fill this deposit. Can be set to 0x0 if no period is desired. If so, then must set exclusivityParameter to 0.\",\"exclusivityParameter\":\"Timestamp or offset, after which any relayer can fill this deposit. Must set to 0 if exclusiveRelayer is set to 0x0, and vice versa.\",\"fillDeadline\":\"Timestamp after which this deposit can no longer be filled.\",\"inputAmount\":\"Amount of tokens to deposit.\",\"inputToken\":\"Token to lock into this contract to initiate deposit.\",\"message\":\"Arbitrary data that can be used to pass additional information to the recipient along with the tokens. Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\",\"outputAmount\":\"Amount of tokens to receive on destination chain.\",\"quoteTimestamp\":\"Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.\",\"recipient\":\"Address to receive funds at on destination chain.\"}},\"depositWithAuthorization(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)\":{\"details\":\"If `acrossInputToken` does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\",\"params\":{\"acrossInputAmount\":\"Amount of the input token to deposit.\",\"acrossInputToken\":\"EIP-3009 compliant token to deposit.\",\"depositData\":\"Specifies the Across deposit params to send.\",\"nonce\":\"Unique nonce used in the `receiveWithAuthorization` signature.\",\"r\":\"r of the EIP-3009 signature.\",\"s\":\"s of the EIP-3009 signature.\",\"v\":\"v of the EIP-3009 signature.\",\"validAfter\":\"The unix time after which the `receiveWithAuthorization` signature is valid.\",\"validBefore\":\"The unix time before which the `receiveWithAuthorization` signature is valid.\"}},\"depositWithPermit(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)\":{\"details\":\"If `acrossInputToken` does not implement `permit` to the specifications of EIP-2612, this function will fail.\",\"params\":{\"acrossInputAmount\":\"Amount of the input token to deposit.\",\"acrossInputToken\":\"EIP-2612 compliant token to deposit.\",\"deadline\":\"Deadline before which the permit signature is valid.\",\"depositData\":\"Specifies the Across deposit params to send.\",\"r\":\"r of the permit signature.\",\"s\":\"s of the permit signature.\",\"v\":\"v of the permit signature.\"}},\"initialize(address,address,address)\":{\"details\":\"These values are initialized in a function and not in the constructor so that the creation code of this contract is the same across networks with different addresses for the wrapped native token, the exchange this contract uses to swap and bridge, and this network's corresponding spoke pool contract. This is to allow this contract to be deterministically deployed with CREATE2.This function can be front-run by anybody, so it is critical to check that the `spokePool`, `wrappedNativeToken`, and `exchange` values used in the single call to this function were passed in correctly before enabling the usage of this contract.\",\"params\":{\"_exchange\":\"Address of the exchange where tokens will be swapped.\",\"_spokePool\":\"Address of the SpokePool contract that we'll submit deposits to.\",\"_wrappedNativeToken\":\"Address of the wrapped native token for the network this contract is deployed to.\"}},\"swapAndBridge(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes))\":{\"details\":\"If swapToken or acrossInputToken are the native token for this chain then this function might fail. the assumption is that this function will handle only ERC20 tokens.\",\"params\":{\"acrossInputToken\":\"Address of the token that will be bridged via Across as the inputToken.\",\"depositData\":\"Specifies the Across deposit params we'll send after the swap.\",\"minExpectedInputTokenAmount\":\"Minimum amount of received depositData.inputToken that we'll submit bridge deposit with.\",\"routerCalldata\":\"ABI encoded function data to call on router. Should form a swap of swapToken for enough of acrossInputToken, otherwise this function will revert.\",\"swapToken\":\"Address of the token that will be swapped for acrossInputToken.\",\"swapTokenAmount\":\"Amount of swapToken to swap for a minimum amount of depositData.inputToken.\"}},\"swapAndBridgeWithAuthorization(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)\":{\"details\":\"If swapToken does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\",\"params\":{\"acrossInputToken\":\"Address of the token that will be bridged via Across as the inputToken.\",\"depositData\":\"Specifies the Across deposit params we'll send after the swap.\",\"minExpectedInputTokenAmount\":\"Minimum amount of received depositData.inputToken that we'll submit bridge deposit with.\",\"nonce\":\"Unique nonce used in the `receiveWithAuthorization` signature.\",\"r\":\"r of the EIP-3009 signature.\",\"routerCalldata\":\"ABI encoded function data to call on router. Should form a swap of swapToken for enough of acrossInputToken, otherwise this function will revert.\",\"s\":\"s of the EIP-3009 signature.\",\"swapToken\":\"Address of the token that will be swapped for acrossInputToken.\",\"swapTokenAmount\":\"Amount of swapToken to swap for a minimum amount of depositData.inputToken.\",\"v\":\"v of the EIP-3009 signature.\",\"validAfter\":\"The unix time after which the `receiveWithAuthorization` signature is valid.\",\"validBefore\":\"The unix time before which the `receiveWithAuthorization` signature is valid.\"}},\"swapAndBridgeWithPermit(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)\":{\"details\":\"If swapToken does not implement `permit` to the specifications of EIP-2612, this function will fail.\",\"params\":{\"acrossInputToken\":\"Address of the token that will be bridged via Across as the inputToken.\",\"deadline\":\"Deadline before which the permit signature is valid.\",\"depositData\":\"Specifies the Across deposit params we'll send after the swap.\",\"minExpectedInputTokenAmount\":\"Minimum amount of received depositData.inputToken that we'll submit bridge deposit with.\",\"r\":\"r of the permit signature.\",\"routerCalldata\":\"ABI encoded function data to call on router. Should form a swap of swapToken for enough of acrossInputToken, otherwise this function will revert.\",\"s\":\"s of the permit signature.\",\"swapToken\":\"Address of the token that will be swapped for acrossInputToken.\",\"swapTokenAmount\":\"Amount of swapToken to swap for a minimum amount of depositData.inputToken.\",\"v\":\"v of the permit signature.\"}}},\"title\":\"SpokePoolV3Periphery\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"constructor\":{\"notice\":\"Construct a new SwapAndBridgeBase contract.\"},\"deposit(address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)\":{\"notice\":\"Passthrough function to `depositV3()` on the SpokePool contract.\"},\"depositWithAuthorization(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)\":{\"notice\":\"Deposits an EIP-3009 compliant Across input token into the Spoke Pool contract.\"},\"depositWithPermit(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)\":{\"notice\":\"Deposits an EIP-2612 token Across input token into the Spoke Pool contract.\"},\"initialize(address,address,address)\":{\"notice\":\"Initializes the SwapAndBridgeBase contract.\"},\"swapAndBridge(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes))\":{\"notice\":\"Swaps tokens on this chain via specified router before submitting Across deposit atomically. Caller can specify their slippage tolerance for the swap and Across deposit params.\"},\"swapAndBridgeWithAuthorization(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)\":{\"notice\":\"Swaps an EIP-3009 token on this chain via specified router before submitting Across deposit atomically. Caller can specify their slippage tolerance for the swap and Across deposit params.\"},\"swapAndBridgeWithPermit(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)\":{\"notice\":\"Swaps an EIP-2612 token on this chain via specified router before submitting Across deposit atomically. Caller can specify their slippage tolerance for the swap and Across deposit params.\"}},\"notice\":\"Contract for performing more complex interactions with an AcrossV3 spoke pool deployment.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/SpokePoolV3Periphery.sol\":\"SpokePoolV3Periphery\"},\"debug\":{\"revertStrings\":\"strip\"},\"evmVersion\":\"shanghai\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[],\"viaIR\":true},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `to`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address to, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `from` to `to` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\\n}\\n\",\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.4) (token/ERC20/extensions/IERC20Permit.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\\n *\\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\\n * need to send a transaction, and thus is not required to hold Ether at all.\\n *\\n * ==== Security Considerations\\n *\\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\\n * generally recommended is:\\n *\\n * ```solidity\\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\\n *     doThing(..., value);\\n * }\\n *\\n * function doThing(..., uint256 value) public {\\n *     token.safeTransferFrom(msg.sender, address(this), value);\\n *     ...\\n * }\\n * ```\\n *\\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\\n * {SafeERC20-safeTransferFrom}).\\n *\\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\\n * contracts should have entry points that don't rely on permit.\\n */\\ninterface IERC20Permit {\\n    /**\\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\\n     * given ``owner``'s signed approval.\\n     *\\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\\n     * ordering also apply here.\\n     *\\n     * Emits an {Approval} event.\\n     *\\n     * Requirements:\\n     *\\n     * - `spender` cannot be the zero address.\\n     * - `deadline` must be a timestamp in the future.\\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\\n     * over the EIP712-formatted function arguments.\\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\\n     *\\n     * For more information on the signature format, see the\\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\\n     * section].\\n     *\\n     * CAUTION: See Security Considerations above.\\n     */\\n    function permit(\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n\\n    /**\\n     * @dev Returns the current nonce for `owner`. This value must be\\n     * included whenever a signature is generated for {permit}.\\n     *\\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\\n     * prevents a signature from being used multiple times.\\n     */\\n    function nonces(address owner) external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\\n     */\\n    // solhint-disable-next-line func-name-mixedcase\\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\\n}\\n\",\"keccak256\":\"0xb264c03a3442eb37a68ad620cefd1182766b58bee6cec40343480392d6b14d69\",\"license\":\"MIT\"},\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\nimport \\\"../IERC20.sol\\\";\\nimport \\\"../extensions/IERC20Permit.sol\\\";\\nimport \\\"../../../utils/Address.sol\\\";\\n\\n/**\\n * @title SafeERC20\\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\\n * contract returns false). Tokens that return no value (and instead revert or\\n * throw on failure) are also supported, non-reverting calls are assumed to be\\n * successful.\\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\\n */\\nlibrary SafeERC20 {\\n    using Address for address;\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\\n    }\\n\\n    /**\\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\\n     */\\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\\n    }\\n\\n    /**\\n     * @dev Deprecated. This function has issues similar to the ones found in\\n     * {IERC20-approve}, and its usage is discouraged.\\n     *\\n     * Whenever possible, use {safeIncreaseAllowance} and\\n     * {safeDecreaseAllowance} instead.\\n     */\\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\\n        // safeApprove should only be called when setting an initial allowance,\\n        // or when resetting it to zero. To increase and decrease it, use\\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\\n        require(\\n            (value == 0) || (token.allowance(address(this), spender) == 0),\\n            \\\"SafeERC20: approve from non-zero to non-zero allowance\\\"\\n        );\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\\n    }\\n\\n    /**\\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        uint256 oldAllowance = token.allowance(address(this), spender);\\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\\n    }\\n\\n    /**\\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful.\\n     */\\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\\n        unchecked {\\n            uint256 oldAllowance = token.allowance(address(this), spender);\\n            require(oldAllowance >= value, \\\"SafeERC20: decreased allowance below zero\\\");\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\\n        }\\n    }\\n\\n    /**\\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\\n     * to be set to zero before setting it to a non-zero value, such as USDT.\\n     */\\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\\n\\n        if (!_callOptionalReturnBool(token, approvalCall)) {\\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\\n            _callOptionalReturn(token, approvalCall);\\n        }\\n    }\\n\\n    /**\\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\\n     * Revert on invalid signature.\\n     */\\n    function safePermit(\\n        IERC20Permit token,\\n        address owner,\\n        address spender,\\n        uint256 value,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) internal {\\n        uint256 nonceBefore = token.nonces(owner);\\n        token.permit(owner, spender, value, deadline, v, r, s);\\n        uint256 nonceAfter = token.nonces(owner);\\n        require(nonceAfter == nonceBefore + 1, \\\"SafeERC20: permit did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     */\\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\\n        // the target address contains contract code and also asserts for success in the low-level call.\\n\\n        bytes memory returndata = address(token).functionCall(data, \\\"SafeERC20: low-level call failed\\\");\\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \\\"SafeERC20: ERC20 operation did not succeed\\\");\\n    }\\n\\n    /**\\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\\n     * @param token The token targeted by the call.\\n     * @param data The call data (encoded using abi.encode or one of its variants).\\n     *\\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\\n     */\\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\\n        // and not revert is the subcall reverts.\\n\\n        (bool success, bytes memory returndata) = address(token).call(data);\\n        return\\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\\n    }\\n}\\n\",\"keccak256\":\"0xabefac93435967b4d36a4fabcbdbb918d1f0b7ae3c3d85bc30923b326c927ed1\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/Address.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\\n\\npragma solidity ^0.8.1;\\n\\n/**\\n * @dev Collection of functions related to the address type\\n */\\nlibrary Address {\\n    /**\\n     * @dev Returns true if `account` is a contract.\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * It is unsafe to assume that an address for which this function returns\\n     * false is an externally-owned account (EOA) and not a contract.\\n     *\\n     * Among others, `isContract` will return false for the following\\n     * types of addresses:\\n     *\\n     *  - an externally-owned account\\n     *  - a contract in construction\\n     *  - an address where a contract will be created\\n     *  - an address where a contract lived, but was destroyed\\n     *\\n     * Furthermore, `isContract` will also return true if the target contract within\\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\\n     * which only has an effect at the end of a transaction.\\n     * ====\\n     *\\n     * [IMPORTANT]\\n     * ====\\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\\n     *\\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\\n     * constructor.\\n     * ====\\n     */\\n    function isContract(address account) internal view returns (bool) {\\n        // This method relies on extcodesize/address.code.length, which returns 0\\n        // for contracts in construction, since the code is only stored at the end\\n        // of the constructor execution.\\n\\n        return account.code.length > 0;\\n    }\\n\\n    /**\\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\\n     * `recipient`, forwarding all available gas and reverting on errors.\\n     *\\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\\n     * imposed by `transfer`, making them unable to receive funds via\\n     * `transfer`. {sendValue} removes this limitation.\\n     *\\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\\n     *\\n     * IMPORTANT: because control is transferred to `recipient`, care must be\\n     * taken to not create reentrancy vulnerabilities. Consider using\\n     * {ReentrancyGuard} or the\\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\\n     */\\n    function sendValue(address payable recipient, uint256 amount) internal {\\n        require(address(this).balance >= amount, \\\"Address: insufficient balance\\\");\\n\\n        (bool success, ) = recipient.call{value: amount}(\\\"\\\");\\n        require(success, \\\"Address: unable to send value, recipient may have reverted\\\");\\n    }\\n\\n    /**\\n     * @dev Performs a Solidity function call using a low level `call`. A\\n     * plain `call` is an unsafe replacement for a function call: use this\\n     * function instead.\\n     *\\n     * If `target` reverts with a revert reason, it is bubbled up by this\\n     * function (like regular Solidity function calls).\\n     *\\n     * Returns the raw returned data. To convert to the expected return value,\\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\\n     *\\n     * Requirements:\\n     *\\n     * - `target` must be a contract.\\n     * - calling `target` with `data` must not revert.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, \\\"Address: low-level call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\\n     * `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, 0, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but also transferring `value` wei to `target`.\\n     *\\n     * Requirements:\\n     *\\n     * - the calling contract must have an ETH balance of at least `value`.\\n     * - the called Solidity function must be `payable`.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\\n        return functionCallWithValue(target, data, value, \\\"Address: low-level call with value failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\\n     *\\n     * _Available since v3.1._\\n     */\\n    function functionCallWithValue(\\n        address target,\\n        bytes memory data,\\n        uint256 value,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        require(address(this).balance >= value, \\\"Address: insufficient balance for call\\\");\\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\\n        return functionStaticCall(target, data, \\\"Address: low-level static call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a static call.\\n     *\\n     * _Available since v3.3._\\n     */\\n    function functionStaticCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.staticcall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\\n        return functionDelegateCall(target, data, \\\"Address: low-level delegate call failed\\\");\\n    }\\n\\n    /**\\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\\n     * but performing a delegate call.\\n     *\\n     * _Available since v3.4._\\n     */\\n    function functionDelegateCall(\\n        address target,\\n        bytes memory data,\\n        string memory errorMessage\\n    ) internal returns (bytes memory) {\\n        (bool success, bytes memory returndata) = target.delegatecall(data);\\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\\n     *\\n     * _Available since v4.8._\\n     */\\n    function verifyCallResultFromTarget(\\n        address target,\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal view returns (bytes memory) {\\n        if (success) {\\n            if (returndata.length == 0) {\\n                // only check isContract if the call was successful and the return data is empty\\n                // otherwise we already know that it was a contract\\n                require(isContract(target), \\\"Address: call to non-contract\\\");\\n            }\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    /**\\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\\n     * revert reason or using the provided one.\\n     *\\n     * _Available since v4.3._\\n     */\\n    function verifyCallResult(\\n        bool success,\\n        bytes memory returndata,\\n        string memory errorMessage\\n    ) internal pure returns (bytes memory) {\\n        if (success) {\\n            return returndata;\\n        } else {\\n            _revert(returndata, errorMessage);\\n        }\\n    }\\n\\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\\n        // Look for revert reason and bubble it up if present\\n        if (returndata.length > 0) {\\n            // The easiest way to bubble the revert reason is using memory via assembly\\n            /// @solidity memory-safe-assembly\\n            assembly {\\n                let returndata_size := mload(returndata)\\n                revert(add(32, returndata), returndata_size)\\n            }\\n        } else {\\n            revert(errorMessage);\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\"},\"@uma/core/contracts/common/implementation/MultiCaller.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n// This contract is taken from Uniswap's multi call implementation (https://github.com/Uniswap/uniswap-v3-periphery/blob/main/contracts/base/Multicall.sol)\\n// and was modified to be solidity 0.8 compatible. Additionally, the method was restricted to only work with msg.value\\n// set to 0 to avoid any nasty attack vectors on function calls that use value sent with deposits.\\n\\n/// @title MultiCaller\\n/// @notice Enables calling multiple methods in a single call to the contract\\ncontract MultiCaller {\\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\\n        results = new bytes[](data.length);\\n        for (uint256 i = 0; i < data.length; i++) {\\n            (bool success, bytes memory result) = address(this).delegatecall(data[i]);\\n\\n            if (!success) {\\n                // Next 5 lines from https://ethereum.stackexchange.com/a/83577\\n                if (result.length < 68) revert();\\n                assembly {\\n                    result := add(result, 0x04)\\n                }\\n                revert(abi.decode(result, (string)));\\n            }\\n\\n            results[i] = result;\\n        }\\n    }\\n}\\n\",\"keccak256\":\"0x9f6afe5bafc5e16fe8d63010a740ec3a88a9f00a7236ea7e5b039a2f50eb346e\",\"license\":\"AGPL-3.0-only\"},\"contracts/Lockable.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @title A contract that provides modifiers to prevent reentrancy to state-changing and view-only methods. This contract\\n * is inspired by https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/ReentrancyGuard.sol\\n * and https://github.com/balancer-labs/balancer-core/blob/master/contracts/BPool.sol.\\n * @dev The reason why we use this local contract instead of importing from uma/contracts is because of the addition\\n * of the internal method `functionCallStackOriginatesFromOutsideThisContract` which doesn't exist in the one exported\\n * by uma/contracts.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract Lockable {\\n    bool internal _notEntered;\\n\\n    constructor() {\\n        // Storing an initial non-zero value makes deployment a bit more expensive, but in exchange the refund on every\\n        // call to nonReentrant will be lower in amount. Since refunds are capped to a percentage of the total\\n        // transaction's gas, it is best to keep them low in cases like this one, to increase the likelihood of the full\\n        // refund coming into effect.\\n        _notEntered = true;\\n    }\\n\\n    /**\\n     * @dev Prevents a contract from calling itself, directly or indirectly.\\n     * Calling a nonReentrant function from another nonReentrant function is not supported. It is possible to\\n     * prevent this from happening by making the nonReentrant function external, and making it call a private\\n     * function that does the actual state modification.\\n     */\\n    modifier nonReentrant() {\\n        _preEntranceCheck();\\n        _preEntranceSet();\\n        _;\\n        _postEntranceReset();\\n    }\\n\\n    /**\\n     * @dev Designed to prevent a view-only method from being re-entered during a call to a nonReentrant() state-changing method.\\n     */\\n    modifier nonReentrantView() {\\n        _preEntranceCheck();\\n        _;\\n    }\\n\\n    /**\\n     * @dev Returns true if the contract is currently in a non-entered state, meaning that the origination of the call\\n     * came from outside the contract. This is relevant with fallback/receive methods to see if the call came from ETH\\n     * being dropped onto the contract externally or due to ETH dropped on the contract from within a method in this\\n     * contract, such as unwrapping WETH to ETH within the contract.\\n     */\\n    function functionCallStackOriginatesFromOutsideThisContract() internal view returns (bool) {\\n        return _notEntered;\\n    }\\n\\n    // Internal methods are used to avoid copying the require statement's bytecode to every nonReentrant() method.\\n    // On entry into a function, _preEntranceCheck() should always be called to check if the function is being\\n    // re-entered. Then, if the function modifies state, it should call _postEntranceSet(), perform its logic, and\\n    // then call _postEntranceReset().\\n    // View-only methods can simply call _preEntranceCheck() to make sure that it is not being re-entered.\\n    function _preEntranceCheck() internal view {\\n        // On the first call to nonReentrant, _notEntered will be true\\n        require(_notEntered, \\\"ReentrancyGuard: reentrant call\\\");\\n    }\\n\\n    function _preEntranceSet() internal {\\n        // Any calls to nonReentrant after this point will fail\\n        _notEntered = false;\\n    }\\n\\n    function _postEntranceReset() internal {\\n        // By storing the original value once again, a refund is triggered (see\\n        // https://eips.ethereum.org/EIPS/eip-2200)\\n        _notEntered = true;\\n    }\\n}\\n\",\"keccak256\":\"0x8f1a93e030b8a610f941935fa5d7433530c3a0a047d617a839996d23889e9666\",\"license\":\"BUSL-1.1\"},\"contracts/SpokePoolV3Periphery.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\nimport { IERC20 } from \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport { SafeERC20 } from \\\"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\\\";\\nimport { IERC20Permit } from \\\"@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol\\\";\\nimport { Address } from \\\"@openzeppelin/contracts/utils/Address.sol\\\";\\nimport { MultiCaller } from \\\"@uma/core/contracts/common/implementation/MultiCaller.sol\\\";\\nimport { Lockable } from \\\"./Lockable.sol\\\";\\nimport { V3SpokePoolInterface } from \\\"./interfaces/V3SpokePoolInterface.sol\\\";\\nimport { IERC20Auth } from \\\"./external/interfaces/IERC20Auth.sol\\\";\\nimport { WETH9Interface } from \\\"./external/interfaces/WETH9Interface.sol\\\";\\n\\n/**\\n * @title SpokePoolV3Periphery\\n * @notice Contract for performing more complex interactions with an AcrossV3 spoke pool deployment.\\n * @dev Variables which may be immutable are not marked as immutable, nor defined in the constructor, so that this contract may be deployed deterministically.\\n * @custom:security-contact bugs@across.to\\n */\\ncontract SpokePoolV3Periphery is Lockable, MultiCaller {\\n    using SafeERC20 for IERC20;\\n    using Address for address;\\n\\n    // This contract performs a low level call with arbirary data to an external contract. This is a large attack\\n    // surface and we should whitelist which function selectors are allowed to be called on the exchange.\\n    mapping(bytes4 => bool) public allowedSelectors;\\n\\n    // Across SpokePool we'll submit deposits to with acrossInputToken as the input token.\\n    V3SpokePoolInterface public spokePool;\\n\\n    // Exchange address or router where the swapping will happen.\\n    address public exchange;\\n\\n    // Wrapped native token contract address.\\n    WETH9Interface internal wrappedNativeToken;\\n\\n    // Boolean indicating whether the contract is initialized.\\n    bool private initialized;\\n\\n    // Params we'll need caller to pass in to specify an Across Deposit. The input token will be swapped into first\\n    // before submitting a bridge deposit, which is why we don't include the input token amount as it is not known\\n    // until after the swap.\\n    struct DepositData {\\n        // Token received on destination chain.\\n        address outputToken;\\n        // Amount of output token to be received by recipient.\\n        uint256 outputAmount;\\n        // The account credited with deposit who can submit speedups to the Across deposit.\\n        address depositor;\\n        // The account that will receive the output token on the destination chain. If the output token is\\n        // wrapped native token, then if this is an EOA then they will receive native token on the destination\\n        // chain and if this is a contract then they will receive an ERC20.\\n        address recipient;\\n        // The destination chain identifier.\\n        uint256 destinationChainid;\\n        // The account that can exclusively fill the deposit before the exclusivity parameter.\\n        address exclusiveRelayer;\\n        // Timestamp of the deposit used by system to charge fees. Must be within short window of time into the past\\n        // relative to this chain's current time or deposit will revert.\\n        uint32 quoteTimestamp;\\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\\n        uint32 fillDeadline;\\n        // The timestamp or offset on the destination chain after which anyone can fill the deposit. A detailed description on\\n        // how the parameter is interpreted by the V3 spoke pool can be found at https://github.com/across-protocol/contracts/blob/fa67f5e97eabade68c67127f2261c2d44d9b007e/contracts/SpokePool.sol#L476\\n        uint32 exclusivityParameter;\\n        // Data that is forwarded to the recipient if the recipient is a contract.\\n        bytes message;\\n    }\\n\\n    event SwapBeforeBridge(\\n        address exchange,\\n        address indexed swapToken,\\n        address indexed acrossInputToken,\\n        uint256 swapTokenAmount,\\n        uint256 acrossInputAmount,\\n        address indexed acrossOutputToken,\\n        uint256 acrossOutputAmount\\n    );\\n\\n    /****************************************\\n     *                ERRORS                *\\n     ****************************************/\\n    error MinimumExpectedInputAmount();\\n    error LeftoverSrcTokens();\\n    error InvalidFunctionSelector();\\n    error ContractInitialized();\\n    error InvalidMsgValue();\\n    error InvalidSpokePool();\\n    error InvalidSwapToken();\\n\\n    /**\\n     * @notice Construct a new SwapAndBridgeBase contract.\\n     * @param _allowedSelectors Function selectors that are allowed to be called on the exchange.\\n     */\\n    constructor(bytes4[] memory _allowedSelectors) {\\n        for (uint256 i = 0; i < _allowedSelectors.length; i++) {\\n            allowedSelectors[_allowedSelectors[i]] = true;\\n        }\\n    }\\n\\n    /**\\n     * @notice Initializes the SwapAndBridgeBase contract.\\n     * @param _spokePool Address of the SpokePool contract that we'll submit deposits to.\\n     * @param _wrappedNativeToken Address of the wrapped native token for the network this contract is deployed to.\\n     * @param _exchange Address of the exchange where tokens will be swapped.\\n     * @dev These values are initialized in a function and not in the constructor so that the creation code of this contract\\n     * is the same across networks with different addresses for the wrapped native token, the exchange this contract uses to\\n     * swap and bridge, and this network's corresponding spoke pool contract. This is to allow this contract to be deterministically\\n     * deployed with CREATE2.\\n     * @dev This function can be front-run by anybody, so it is critical to check that the `spokePool`, `wrappedNativeToken`, and `exchange`\\n     * values used in the single call to this function were passed in correctly before enabling the usage of this contract.\\n     */\\n    function initialize(\\n        V3SpokePoolInterface _spokePool,\\n        WETH9Interface _wrappedNativeToken,\\n        address _exchange\\n    ) external {\\n        if (initialized) revert ContractInitialized();\\n        initialized = true;\\n\\n        spokePool = _spokePool;\\n        wrappedNativeToken = _wrappedNativeToken;\\n        exchange = _exchange;\\n    }\\n\\n    /**\\n     * @notice Passthrough function to `depositV3()` on the SpokePool contract.\\n     * @dev Protects the caller from losing their ETH (or other native token) by reverting if the SpokePool address\\n     * they intended to call does not exist on this chain. Because this contract can be deployed at the same address\\n     * everywhere callers should be protected even if the transaction is submitted to an unintended network.\\n     * This contract should only be used for native token deposits, as this problem only exists for native tokens.\\n     * @param recipient Address to receive funds at on destination chain.\\n     * @param inputToken Token to lock into this contract to initiate deposit.\\n     * @param inputAmount Amount of tokens to deposit.\\n     * @param outputAmount Amount of tokens to receive on destination chain.\\n     * @param destinationChainId Denotes network where user will receive funds from SpokePool by a relayer.\\n     * @param quoteTimestamp Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid\\n     * to LP pool on HubPool.\\n     * @param message Arbitrary data that can be used to pass additional information to the recipient along with the tokens.\\n     * Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.\\n     * @param exclusiveRelayer Address of the relayer who has exclusive rights to fill this deposit. Can be set to\\n     * 0x0 if no period is desired. If so, then must set exclusivityParameter to 0.\\n     * @param exclusivityParameter Timestamp or offset, after which any relayer can fill this deposit. Must set\\n     * to 0 if exclusiveRelayer is set to 0x0, and vice versa.\\n     * @param fillDeadline Timestamp after which this deposit can no longer be filled.\\n     */\\n    function deposit(\\n        address recipient,\\n        address inputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityParameter,\\n        bytes memory message\\n    ) external payable nonReentrant {\\n        if (msg.value != inputAmount) revert InvalidMsgValue();\\n        if (!address(spokePool).isContract()) revert InvalidSpokePool();\\n        // Set msg.sender as the depositor so that msg.sender can speed up the deposit.\\n        spokePool.depositV3{ value: msg.value }(\\n            msg.sender,\\n            recipient,\\n            inputToken,\\n            // @dev Setting outputToken to 0x0 to instruct fillers to use the equivalent token\\n            // as the originToken on the destination chain.\\n            address(0),\\n            inputAmount,\\n            outputAmount,\\n            destinationChainId,\\n            exclusiveRelayer,\\n            quoteTimestamp,\\n            fillDeadline,\\n            exclusivityParameter,\\n            message\\n        );\\n    }\\n\\n    /**\\n     * @notice Swaps tokens on this chain via specified router before submitting Across deposit atomically.\\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\\n     * @dev If swapToken or acrossInputToken are the native token for this chain then this function might fail.\\n     * the assumption is that this function will handle only ERC20 tokens.\\n     * @param swapToken Address of the token that will be swapped for acrossInputToken.\\n     * @param acrossInputToken Address of the token that will be bridged via Across as the inputToken.\\n     * @param routerCalldata ABI encoded function data to call on router. Should form a swap of swapToken for\\n     * enough of acrossInputToken, otherwise this function will revert.\\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of depositData.inputToken.\\n     * @param minExpectedInputTokenAmount Minimum amount of received depositData.inputToken that we'll submit bridge\\n     * deposit with.\\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\\n     */\\n    function swapAndBridge(\\n        IERC20 swapToken,\\n        IERC20 acrossInputToken,\\n        bytes calldata routerCalldata,\\n        uint256 swapTokenAmount,\\n        uint256 minExpectedInputTokenAmount,\\n        DepositData calldata depositData\\n    ) external payable nonReentrant {\\n        // If a user performs a swapAndBridge with the swap token as the native token, wrap the value and treat the rest of transaction\\n        // as though the user deposited a wrapped native token.\\n        if (msg.value != 0) {\\n            if (msg.value != swapTokenAmount) revert InvalidMsgValue();\\n            if (address(swapToken) != address(wrappedNativeToken)) revert InvalidSwapToken();\\n            wrappedNativeToken.deposit{ value: msg.value }();\\n        } else {\\n            swapToken.safeTransferFrom(msg.sender, address(this), swapTokenAmount);\\n        }\\n        _swapAndBridge(\\n            routerCalldata,\\n            swapTokenAmount,\\n            minExpectedInputTokenAmount,\\n            depositData,\\n            swapToken,\\n            acrossInputToken\\n        );\\n    }\\n\\n    /**\\n     * @notice Swaps an EIP-2612 token on this chain via specified router before submitting Across deposit atomically.\\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\\n     * @dev If swapToken does not implement `permit` to the specifications of EIP-2612, this function will fail.\\n     * @param swapToken Address of the token that will be swapped for acrossInputToken.\\n     * @param acrossInputToken Address of the token that will be bridged via Across as the inputToken.\\n     * @param routerCalldata ABI encoded function data to call on router. Should form a swap of swapToken for\\n     * enough of acrossInputToken, otherwise this function will revert.\\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of depositData.inputToken.\\n     * @param minExpectedInputTokenAmount Minimum amount of received depositData.inputToken that we'll submit bridge\\n     * deposit with.\\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\\n     * @param deadline Deadline before which the permit signature is valid.\\n     * @param v v of the permit signature.\\n     * @param r r of the permit signature.\\n     * @param s s of the permit signature.\\n     */\\n    function swapAndBridgeWithPermit(\\n        IERC20Permit swapToken,\\n        IERC20 acrossInputToken,\\n        bytes calldata routerCalldata,\\n        uint256 swapTokenAmount,\\n        uint256 minExpectedInputTokenAmount,\\n        DepositData calldata depositData,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external nonReentrant {\\n        IERC20 _swapToken = IERC20(address(swapToken)); // Cast IERC20Permit to IERC20.\\n        // For permit transactions, we wrap the call in a try/catch block so that the transaction will continue even if the call to\\n        // permit fails. For example, this may be useful if the permit signature, which can be redeemed by anyone, is executed by somebody\\n        // other than this contract.\\n        try swapToken.permit(msg.sender, address(this), swapTokenAmount, deadline, v, r, s) {} catch {}\\n\\n        _swapToken.safeTransferFrom(msg.sender, address(this), swapTokenAmount);\\n        _swapAndBridge(\\n            routerCalldata,\\n            swapTokenAmount,\\n            minExpectedInputTokenAmount,\\n            depositData,\\n            _swapToken,\\n            acrossInputToken\\n        );\\n    }\\n\\n    /**\\n     * @notice Swaps an EIP-3009 token on this chain via specified router before submitting Across deposit atomically.\\n     * Caller can specify their slippage tolerance for the swap and Across deposit params.\\n     * @dev If swapToken does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\\n     * @param swapToken Address of the token that will be swapped for acrossInputToken.\\n     * @param acrossInputToken Address of the token that will be bridged via Across as the inputToken.\\n     * @param routerCalldata ABI encoded function data to call on router. Should form a swap of swapToken for\\n     * enough of acrossInputToken, otherwise this function will revert.\\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of depositData.inputToken.\\n     * @param minExpectedInputTokenAmount Minimum amount of received depositData.inputToken that we'll submit bridge\\n     * deposit with.\\n     * @param depositData Specifies the Across deposit params we'll send after the swap.\\n     * @param validAfter The unix time after which the `receiveWithAuthorization` signature is valid.\\n     * @param validBefore The unix time before which the `receiveWithAuthorization` signature is valid.\\n     * @param nonce Unique nonce used in the `receiveWithAuthorization` signature.\\n     * @param v v of the EIP-3009 signature.\\n     * @param r r of the EIP-3009 signature.\\n     * @param s s of the EIP-3009 signature.\\n     */\\n    function swapAndBridgeWithAuthorization(\\n        IERC20Auth swapToken,\\n        IERC20 acrossInputToken,\\n        bytes calldata routerCalldata,\\n        uint256 swapTokenAmount,\\n        uint256 minExpectedInputTokenAmount,\\n        DepositData calldata depositData,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external nonReentrant {\\n        // While any contract can vacuously implement `transferWithAuthorization` (or just have a fallback),\\n        // if tokens were not sent to this contract, by this call to the swapToken, the call to `transferFrom`\\n        // in _swapAndBridge will revert.\\n        swapToken.receiveWithAuthorization(\\n            msg.sender,\\n            address(this),\\n            swapTokenAmount,\\n            validAfter,\\n            validBefore,\\n            nonce,\\n            v,\\n            r,\\n            s\\n        );\\n        IERC20 _swapToken = IERC20(address(swapToken)); // Cast IERC20Auth to IERC20.\\n\\n        _swapAndBridge(\\n            routerCalldata,\\n            swapTokenAmount,\\n            minExpectedInputTokenAmount,\\n            depositData,\\n            _swapToken,\\n            acrossInputToken\\n        );\\n    }\\n\\n    /**\\n     * @notice Deposits an EIP-2612 token Across input token into the Spoke Pool contract.\\n     * @dev If `acrossInputToken` does not implement `permit` to the specifications of EIP-2612, this function will fail.\\n     * @param acrossInputToken EIP-2612 compliant token to deposit.\\n     * @param acrossInputAmount Amount of the input token to deposit.\\n     * @param depositData Specifies the Across deposit params to send.\\n     * @param deadline Deadline before which the permit signature is valid.\\n     * @param v v of the permit signature.\\n     * @param r r of the permit signature.\\n     * @param s s of the permit signature.\\n     */\\n    function depositWithPermit(\\n        IERC20Permit acrossInputToken,\\n        uint256 acrossInputAmount,\\n        DepositData calldata depositData,\\n        uint256 deadline,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external nonReentrant {\\n        IERC20 _acrossInputToken = IERC20(address(acrossInputToken)); // Cast IERC20Permit to an IERC20 type.\\n        // For permit transactions, we wrap the call in a try/catch block so that the transaction will continue even if the call to\\n        // permit fails. For example, this may be useful if the permit signature, which can be redeemed by anyone, is executed by somebody\\n        // other than this contract.\\n        try acrossInputToken.permit(msg.sender, address(this), acrossInputAmount, deadline, v, r, s) {} catch {}\\n\\n        _acrossInputToken.safeTransferFrom(msg.sender, address(this), acrossInputAmount);\\n        _depositV3(_acrossInputToken, acrossInputAmount, depositData);\\n    }\\n\\n    /**\\n     * @notice Deposits an EIP-3009 compliant Across input token into the Spoke Pool contract.\\n     * @dev If `acrossInputToken` does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.\\n     * @param acrossInputToken EIP-3009 compliant token to deposit.\\n     * @param acrossInputAmount Amount of the input token to deposit.\\n     * @param depositData Specifies the Across deposit params to send.\\n     * @param validAfter The unix time after which the `receiveWithAuthorization` signature is valid.\\n     * @param validBefore The unix time before which the `receiveWithAuthorization` signature is valid.\\n     * @param nonce Unique nonce used in the `receiveWithAuthorization` signature.\\n     * @param v v of the EIP-3009 signature.\\n     * @param r r of the EIP-3009 signature.\\n     * @param s s of the EIP-3009 signature.\\n     */\\n    function depositWithAuthorization(\\n        IERC20Auth acrossInputToken,\\n        uint256 acrossInputAmount,\\n        DepositData calldata depositData,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external nonReentrant {\\n        acrossInputToken.receiveWithAuthorization(\\n            msg.sender,\\n            address(this),\\n            acrossInputAmount,\\n            validAfter,\\n            validBefore,\\n            nonce,\\n            v,\\n            r,\\n            s\\n        );\\n        IERC20 _acrossInputToken = IERC20(address(acrossInputToken)); // Cast the input token to an IERC20.\\n        _depositV3(_acrossInputToken, acrossInputAmount, depositData);\\n    }\\n\\n    /**\\n     * @notice Approves the spoke pool and calls `depositV3` function with the specified input parameters.\\n     * @param _acrossInputToken Token to deposit into the spoke pool.\\n     * @param _acrossInputAmount Amount of the input token to deposit into the spoke pool.\\n     * @param depositData Specifies the Across deposit params to use.\\n     */\\n    function _depositV3(\\n        IERC20 _acrossInputToken,\\n        uint256 _acrossInputAmount,\\n        DepositData calldata depositData\\n    ) private {\\n        _acrossInputToken.safeIncreaseAllowance(address(spokePool), _acrossInputAmount);\\n        spokePool.depositV3(\\n            depositData.depositor,\\n            depositData.recipient,\\n            address(_acrossInputToken), // input token\\n            depositData.outputToken, // output token\\n            _acrossInputAmount, // input amount.\\n            depositData.outputAmount, // output amount\\n            depositData.destinationChainid,\\n            depositData.exclusiveRelayer,\\n            depositData.quoteTimestamp,\\n            depositData.fillDeadline,\\n            depositData.exclusivityParameter,\\n            depositData.message\\n        );\\n    }\\n\\n    // This contract supports two variants of swap and bridge, one that allows one token and another that allows the caller to pass them in.\\n    function _swapAndBridge(\\n        bytes calldata routerCalldata,\\n        uint256 swapTokenAmount,\\n        uint256 minExpectedInputTokenAmount,\\n        DepositData calldata depositData,\\n        IERC20 _swapToken,\\n        IERC20 _acrossInputToken\\n    ) private {\\n        // Note: this check should never be impactful, but is here out of an abundance of caution.\\n        // For example, if the exchange address in the contract is also an ERC20 token that is approved by some\\n        // user on this contract, a malicious actor could call transferFrom to steal the user's tokens.\\n        if (!allowedSelectors[bytes4(routerCalldata)]) revert InvalidFunctionSelector();\\n\\n        // Swap and run safety checks.\\n        uint256 srcBalanceBefore = _swapToken.balanceOf(address(this));\\n        uint256 dstBalanceBefore = _acrossInputToken.balanceOf(address(this));\\n\\n        _swapToken.safeIncreaseAllowance(exchange, swapTokenAmount);\\n        // solhint-disable-next-line avoid-low-level-calls\\n        (bool success, bytes memory result) = exchange.call(routerCalldata);\\n        require(success, string(result));\\n\\n        _checkSwapOutputAndDeposit(\\n            swapTokenAmount,\\n            srcBalanceBefore,\\n            dstBalanceBefore,\\n            minExpectedInputTokenAmount,\\n            depositData,\\n            _swapToken,\\n            _acrossInputToken\\n        );\\n    }\\n\\n    /**\\n     * @notice Check that the swap returned enough tokens to submit an Across deposit with and then submit the deposit.\\n     * @param swapTokenAmount Amount of swapToken to swap for a minimum amount of acrossInputToken.\\n     * @param swapTokenBalanceBefore Balance of swapToken before swap.\\n     * @param inputTokenBalanceBefore Amount of Across input token we held before swap\\n     * @param minExpectedInputTokenAmount Minimum amount of received acrossInputToken that we'll bridge\\n     **/\\n    function _checkSwapOutputAndDeposit(\\n        uint256 swapTokenAmount,\\n        uint256 swapTokenBalanceBefore,\\n        uint256 inputTokenBalanceBefore,\\n        uint256 minExpectedInputTokenAmount,\\n        DepositData calldata depositData,\\n        IERC20 _swapToken,\\n        IERC20 _acrossInputToken\\n    ) private {\\n        // Sanity check that we received as many tokens as we require:\\n        uint256 returnAmount = _acrossInputToken.balanceOf(address(this)) - inputTokenBalanceBefore;\\n        // Sanity check that received amount from swap is enough to submit Across deposit with.\\n        if (returnAmount < minExpectedInputTokenAmount) revert MinimumExpectedInputAmount();\\n        // Sanity check that we don't have any leftover swap tokens that would be locked in this contract (i.e. check\\n        // that we weren't partial filled).\\n        if (swapTokenBalanceBefore - _swapToken.balanceOf(address(this)) != swapTokenAmount) revert LeftoverSrcTokens();\\n\\n        emit SwapBeforeBridge(\\n            exchange,\\n            address(_swapToken),\\n            address(_acrossInputToken),\\n            swapTokenAmount,\\n            returnAmount,\\n            depositData.outputToken,\\n            depositData.outputAmount\\n        );\\n        // Deposit the swapped tokens into Across and bridge them using remainder of input params.\\n        _depositV3(_acrossInputToken, returnAmount, depositData);\\n    }\\n}\\n\",\"keccak256\":\"0x168ec630e696f68e438574eb4b63d34e6a7da4b192979d00dd026c8c4465e43b\",\"license\":\"Unlicense\"},\"contracts/external/interfaces/IERC20Auth.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/*\\n * @notice Minimal interface for an EIP-3009 compliant token.\\n * https://eips.ethereum.org/EIPS/eip-3009\\n */\\ninterface IERC20Auth {\\n    /**\\n     * @notice Receive a transfer with a signed authorization from the payer\\n     * @dev This has an additional check to ensure that the payee's address matches\\n     * the caller of this function to prevent front-running attacks. (See security\\n     * considerations)\\n     * @param from          Payer's address (Authorizer)\\n     * @param to            Payee's address\\n     * @param value         Amount to be transferred\\n     * @param validAfter    The time after which this is valid (unix time)\\n     * @param validBefore   The time before which this is valid (unix time)\\n     * @param nonce         Unique nonce\\n     * @param v             v of the signature\\n     * @param r             r of the signature\\n     * @param s             s of the signature\\n     */\\n    function receiveWithAuthorization(\\n        address from,\\n        address to,\\n        uint256 value,\\n        uint256 validAfter,\\n        uint256 validBefore,\\n        bytes32 nonce,\\n        uint8 v,\\n        bytes32 r,\\n        bytes32 s\\n    ) external;\\n}\\n\",\"keccak256\":\"0x9a36f56b918c50e7798dc6a5fee95daeb6da3bd6d299f5b450a970ba52a6ce46\",\"license\":\"BUSL-1.1\"},\"contracts/external/interfaces/WETH9Interface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Interface for the WETH9 contract.\\n */\\ninterface WETH9Interface {\\n    /**\\n     * @notice Burn Wrapped Ether and receive native Ether.\\n     * @param wad Amount of WETH to unwrap and send to caller.\\n     */\\n    function withdraw(uint256 wad) external;\\n\\n    /**\\n     * @notice Lock native Ether and mint Wrapped Ether ERC20\\n     * @dev msg.value is amount of Wrapped Ether to mint/Ether to lock.\\n     */\\n    function deposit() external payable;\\n\\n    /**\\n     * @notice Get balance of WETH held by `guy`.\\n     * @param guy Address to get balance of.\\n     * @return wad Amount of WETH held by `guy`.\\n     */\\n    function balanceOf(address guy) external view returns (uint256 wad);\\n\\n    /**\\n     * @notice Transfer `wad` of WETH from caller to `guy`.\\n     * @param guy Address to send WETH to.\\n     * @param wad Amount of WETH to send.\\n     * @return ok True if transfer succeeded.\\n     */\\n    function transfer(address guy, uint256 wad) external returns (bool);\\n}\\n\",\"keccak256\":\"0x3f7892554ec7f54681fdd3cc18a41346c246c9c1afba016c52990ef77741f718\",\"license\":\"BUSL-1.1\"},\"contracts/interfaces/V3SpokePoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: BUSL-1.1\\npragma solidity ^0.8.0;\\n\\n// Contains structs and functions used by SpokePool contracts to facilitate universal settlement.\\ninterface V3SpokePoolInterface {\\n    /**************************************\\n     *              ENUMS                 *\\n     **************************************/\\n\\n    // Fill status tracks on-chain state of deposit, uniquely identified by relayHash.\\n    enum FillStatus {\\n        Unfilled,\\n        RequestedSlowFill,\\n        Filled\\n    }\\n    // Fill type is emitted in the FilledRelay event to assist Dataworker with determining which types of\\n    // fills to refund (e.g. only fast fills) and whether a fast fill created a sow fill excess.\\n    enum FillType {\\n        FastFill,\\n        // Fast fills are normal fills that do not replace a slow fill request.\\n        ReplacedSlowFill,\\n        // Replaced slow fills are fast fills that replace a slow fill request. This type is used by the Dataworker\\n        // to know when to send excess funds from the SpokePool to the HubPool because they can no longer be used\\n        // for a slow fill execution.\\n        SlowFill\\n        // Slow fills are requested via requestSlowFill and executed by executeSlowRelayLeaf after a bundle containing\\n        // the slow fill is validated.\\n    }\\n\\n    /**************************************\\n     *              STRUCTS               *\\n     **************************************/\\n\\n    // This struct represents the data to fully specify a **unique** relay submitted on this chain.\\n    // This data is hashed with the chainId() and saved by the SpokePool to prevent collisions and protect against\\n    // replay attacks on other chains. If any portion of this data differs, the relay is considered to be\\n    // completely distinct.\\n    struct V3RelayData {\\n        // The address that made the deposit on the origin chain.\\n        address depositor;\\n        // The recipient address on the destination chain.\\n        address recipient;\\n        // This is the exclusive relayer who can fill the deposit before the exclusivity deadline.\\n        address exclusiveRelayer;\\n        // Token that is deposited on origin chain by depositor.\\n        address inputToken;\\n        // Token that is received on destination chain by recipient.\\n        address outputToken;\\n        // The amount of input token deposited by depositor.\\n        uint256 inputAmount;\\n        // The amount of output token to be received by recipient.\\n        uint256 outputAmount;\\n        // Origin chain id.\\n        uint256 originChainId;\\n        // The id uniquely identifying this deposit on the origin chain.\\n        uint32 depositId;\\n        // The timestamp on the destination chain after which this deposit can no longer be filled.\\n        uint32 fillDeadline;\\n        // The timestamp on the destination chain after which any relayer can fill the deposit.\\n        uint32 exclusivityDeadline;\\n        // Data that is forwarded to the recipient.\\n        bytes message;\\n    }\\n\\n    // Contains parameters passed in by someone who wants to execute a slow relay leaf.\\n    struct V3SlowFill {\\n        V3RelayData relayData;\\n        uint256 chainId;\\n        uint256 updatedOutputAmount;\\n    }\\n\\n    // Contains information about a relay to be sent along with additional information that is not unique to the\\n    // relay itself but is required to know how to process the relay. For example, \\\"updatedX\\\" fields can be used\\n    // by the relayer to modify fields of the relay with the depositor's permission, and \\\"repaymentChainId\\\" is specified\\n    // by the relayer to determine where to take a relayer refund, but doesn't affect the uniqueness of the relay.\\n    struct V3RelayExecutionParams {\\n        V3RelayData relay;\\n        bytes32 relayHash;\\n        uint256 updatedOutputAmount;\\n        address updatedRecipient;\\n        bytes updatedMessage;\\n        uint256 repaymentChainId;\\n    }\\n\\n    // Packs together parameters emitted in FilledV3Relay because there are too many emitted otherwise.\\n    // Similar to V3RelayExecutionParams, these parameters are not used to uniquely identify the deposit being\\n    // filled so they don't have to be unpacked by all clients.\\n    struct V3RelayExecutionEventInfo {\\n        address updatedRecipient;\\n        bytes updatedMessage;\\n        uint256 updatedOutputAmount;\\n        FillType fillType;\\n    }\\n\\n    /**************************************\\n     *              EVENTS                *\\n     **************************************/\\n\\n    event V3FundsDeposited(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 indexed destinationChainId,\\n        uint32 indexed depositId,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        address indexed depositor,\\n        address recipient,\\n        address exclusiveRelayer,\\n        bytes message\\n    );\\n\\n    event RequestedSpeedUpV3Deposit(\\n        uint256 updatedOutputAmount,\\n        uint32 indexed depositId,\\n        address indexed depositor,\\n        address updatedRecipient,\\n        bytes updatedMessage,\\n        bytes depositorSignature\\n    );\\n\\n    event FilledV3Relay(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 repaymentChainId,\\n        uint256 indexed originChainId,\\n        uint32 indexed depositId,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        address exclusiveRelayer,\\n        address indexed relayer,\\n        address depositor,\\n        address recipient,\\n        bytes message,\\n        V3RelayExecutionEventInfo relayExecutionInfo\\n    );\\n\\n    event RequestedV3SlowFill(\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 indexed originChainId,\\n        uint32 indexed depositId,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        address exclusiveRelayer,\\n        address depositor,\\n        address recipient,\\n        bytes message\\n    );\\n\\n    /**************************************\\n     *              FUNCTIONS             *\\n     **************************************/\\n\\n    function depositV3(\\n        address depositor,\\n        address recipient,\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 quoteTimestamp,\\n        uint32 fillDeadline,\\n        uint32 exclusivityDeadline,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function depositV3Now(\\n        address depositor,\\n        address recipient,\\n        address inputToken,\\n        address outputToken,\\n        uint256 inputAmount,\\n        uint256 outputAmount,\\n        uint256 destinationChainId,\\n        address exclusiveRelayer,\\n        uint32 fillDeadlineOffset,\\n        uint32 exclusivityDeadline,\\n        bytes calldata message\\n    ) external payable;\\n\\n    function speedUpV3Deposit(\\n        address depositor,\\n        uint32 depositId,\\n        uint256 updatedOutputAmount,\\n        address updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) external;\\n\\n    function fillV3Relay(V3RelayData calldata relayData, uint256 repaymentChainId) external;\\n\\n    function fillV3RelayWithUpdatedDeposit(\\n        V3RelayData calldata relayData,\\n        uint256 repaymentChainId,\\n        uint256 updatedOutputAmount,\\n        address updatedRecipient,\\n        bytes calldata updatedMessage,\\n        bytes calldata depositorSignature\\n    ) external;\\n\\n    function requestV3SlowFill(V3RelayData calldata relayData) external;\\n\\n    function executeV3SlowRelayLeaf(\\n        V3SlowFill calldata slowFillLeaf,\\n        uint32 rootBundleId,\\n        bytes32[] calldata proof\\n    ) external;\\n\\n    /**************************************\\n     *              ERRORS                *\\n     **************************************/\\n\\n    error DisabledRoute();\\n    error InvalidQuoteTimestamp();\\n    error InvalidFillDeadline();\\n    error InvalidExclusiveRelayer();\\n    error MsgValueDoesNotMatchInputAmount();\\n    error NotExclusiveRelayer();\\n    error NoSlowFillsInExclusivityWindow();\\n    error RelayFilled();\\n    error InvalidSlowFillRequest();\\n    error ExpiredFillDeadline();\\n    error InvalidMerkleProof();\\n    error InvalidChainId();\\n    error InvalidMerkleLeaf();\\n    error ClaimedMerkleLeaf();\\n    error InvalidPayoutAdjustmentPct();\\n    error WrongERC7683OrderId();\\n    error LowLevelCallFailed(bytes data);\\n}\\n\",\"keccak256\":\"0xb8abcd3eb1d10fccbd39e4a5be893978393616118defaf74e81774adf586a53c\",\"license\":\"BUSL-1.1\"}},\"version\":1}",
  "bytecode": "0x60406080604052346200011c5762001e1e803803806200001f8162000134565b928339810160209081838203126200011c5782516001600160401b03938482116200011c57019080601f830112156200011c57815193841162000120576005918460051b9084806200007381850162000134565b8098815201928201019283116200011c578401905b828210620000fa57505050600193849360ff19936001855f5416175f555f955b620000be575b604051611cc390816200015b8239f35b8151861015620000f45786809663ffffffff60e01b8382881b86010151165f52818352845f2082888254161790550195620000a8565b620000ae565b81516001600160e01b0319811681036200011c57815290840190840162000088565b5f80fd5b634e487b7160e01b5f52604160045260245ffd5b6040519190601f01601f191682016001600160401b03811183821017620001205760405256fe60806040526004361015610011575f80fd5b5f3560e01c8063038f12ea146100c4578063277deffe146100bf57806327e98fbd146100ba57806385f168eb146100b5578063ac9650d8146100b0578063afdac3d6146100ab578063bdf52ad3146100a6578063c0c53b8b146100a1578063c51e5eb91461009c578063d2f7265a146100975763fdf152d314610092575f80fd5b610b13565b610ac2565b6108a0565b61074d565b6106c0565b61066f565b6105dd565b610481565b61039b565b610224565b610175565b73ffffffffffffffffffffffffffffffffffffffff8116036100e757565b5f80fd5b600435906100f8826100c9565b565b602435906100f8826100c9565b9181601f840112156100e75782359167ffffffffffffffff83116100e757602083818601950101116100e757565b90816101409103126100e75790565b610124359060ff821682036100e757565b60e4359060ff821682036100e757565b6084359060ff821682036100e757565b346100e7576101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576101ad6100eb565b6101b56100fa565b67ffffffffffffffff91906044358381116100e7576101d8903690600401610107565b9260a4359485116100e7576101f4610222953690600401610135565b936101fd610144565b9261016435956101443595610104359460e4359460c435946084359360643593610c95565b005b346100e7576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757600435610260816100c9565b6102686100fa565b67ffffffffffffffff91906044358381116100e75761028b903690600401610107565b919060a4359485116100e7576102a8610222953690600401610135565b6102b0610155565b926101243595610104359560c435946084359360643593610dc0565b63ffffffff8116036100e757565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161031b57604052565b6102da565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761031b57604052565b67ffffffffffffffff811161031b57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b6101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576004356103d2816100c9565b6024356103de816100c9565b60a4356103ea816100c9565b60c4356103f6816102cc565b60e43590610403826102cc565b6101043592610411846102cc565b610124359567ffffffffffffffff87116100e757366023880112156100e75786600401359561043f87610361565b9661044d6040519889610320565b808852366024828b0101116100e7576020815f9260246102229c01838c013789010152608435916064359160443591610ea0565b346100e75760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576004357fffffffff0000000000000000000000000000000000000000000000000000000081168091036100e7575f526001602052602060ff60405f2054166040519015158152f35b5f5b8381106105095750505f910152565b81810151838201526020016104fa565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602093610555815180928187528780880191016104f8565b0116010190565b6020808201906020835283518092526040830192602060408460051b8301019501935f915b8483106105915750505050505090565b90919293949584806105cd837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a51610519565b9801930193019194939290610581565b346100e75760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e75767ffffffffffffffff6004358181116100e757366023820112156100e75780600401359182116100e7573660248360051b830101116100e75761066191602461065592016111e4565b6040519182918261055c565b0390f35b5f9103126100e757565b346100e7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b346100e7576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576004356106fc816100c9565b60443567ffffffffffffffff81116100e75761071c903690600401610135565b9060c4359160ff831683036100e75761022292610104359260e4359260a435916084359160643591602435906112cb565b346100e75760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757600435610788816100c9565b60243590610795826100c9565b604435906107a2826100c9565b60045460ff8160a01c16610876577fffffffffffffffffffffff00000000000000000000000000000000000000000074010000000000000000000000000000000000000000926102229573ffffffffffffffffffffffffffffffffffffffff8092167fffffffffffffffffffffffff00000000000000000000000000000000000000006002541617600255169116171760045573ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff00000000000000000000000000000000000000006003541617600355565b60046040517f9f4eefba000000000000000000000000000000000000000000000000000000008152fd5b60c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757600480356108d7816100c9565b602435906108e4826100c9565b67ffffffffffffffff6044358181116100e7576109049036908601610107565b916064359060a4359081116100e7576109209036908801610135565b926109296113c2565b6109547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f55565b3415610aac57813403610a835773ffffffffffffffffffffffffffffffffffffffff6109b0610997895473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b9080821690871603610a5a57803b156100e7575f90604051988980927fd0e30db000000000000000000000000000000000000000000000000000000000825234905af1968715610a5557610a0e97610a3c575b505b60843592611421565b61022260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b80610a49610a4f92610307565b80610665565b5f610a03565b610db5565b876040517f3539a701000000000000000000000000000000000000000000000000000000008152fd5b866040517f1841b4e1000000000000000000000000000000000000000000000000000000008152fd5b610a0e9650610abd82303388611606565b610a05565b346100e7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757602073ffffffffffffffffffffffffffffffffffffffff60035416604051908152f35b346100e7575f60e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e75760043590610b50826100c9565b60243560443567ffffffffffffffff81116100e757610b73903690600401610135565b9073ffffffffffffffffffffffffffffffffffffffff610b91610165565b94610b9a6113c2565b610bc57fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f55565b1693843b156100e7576040517fd505accf00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101839052606480359082015260ff91909116608482015260a480359082015260c48035908201525f8160e48183895af1610c80575b50610c4f9293610c4a82303384611606565b611765565b610c7d60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b80f35b610c4f9350610c8e90610307565b5f92610c38565b73ffffffffffffffffffffffffffffffffffffffff909c9a919b94979295989396999c610cc06113c2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f5516998a3b156100e7576040517fef55bec6000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018990526064810193909352608483019390935260a482019b909b5260ff909a1660c48b015260e48a01919091526101048901525f8861012481838a5af1978815610a5557610d7898610da6575b50611421565b6100f860017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b610daf90610307565b5f610d72565b6040513d5f823e3d90fd5b73ffffffffffffffffffffffffffffffffffffffff909a91999293949596979a610de86113c2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f551697883b156100e7576040517fd505accf00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481019b909b5260ff1660848b015260a48a019190915260c4890152610d78975f8160e481838b5af1610e91575b50610e8c83303389611606565b611421565b610e9a90610307565b5f610e7f565b939298919697909497610eb16113c2565b610edc7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f55565b873403610fce57610f0561099760025473ffffffffffffffffffffffffffffffffffffffff1690565b96873b15610fa457873b156100e7575f99610f51956040519c8d9b8c9a8b9a7f7b939232000000000000000000000000000000000000000000000000000000008c523360048d01610ff8565b039134905af18015610a5557610f91575b506100f860017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b80610a49610f9e92610307565b5f610f62565b60046040517fb474246c000000000000000000000000000000000000000000000000000000008152fd5b60046040517f1841b4e1000000000000000000000000000000000000000000000000000000008152fd5b9794909361107c9b9a969294999793996101809a73ffffffffffffffffffffffffffffffffffffffff8097818094168d521660208c01521660408a01525f60608a0152608089015260a088015260c08701521660e085015263ffffffff92838092166101008601521661012084015216610140820152816101608201520190610519565b90565b67ffffffffffffffff811161031b5760051b60200190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156100e7570180359067ffffffffffffffff82116100e7576020019181360383136100e757565b908210156111305761112c9160051b8101906110c4565b9091565b611097565b908092918237015f815290565b3d1561116c573d9061115382610361565b916111616040519384610320565b82523d5f602084013e565b606090565b6020818303126100e75780519067ffffffffffffffff82116100e7570181601f820112156100e75780516111a481610361565b926111b26040519485610320565b818452602082840101116100e75761107c91602080850191016104f8565b80518210156111305760209160051b010190565b9190916111f08361107f565b9060406112006040519384610320565b8483527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061122d8661107f565b015f5b8181106112ba57505082945f5b81811061124b575050505050565b5f80611258838588611115565b90611267875180938193611135565b0390305af4611274611142565b901561129a579060019161128882886111d0565b5261129381876111d0565b500161123d565b60448151106100e7578060046100e7920151602480918301019101611171565b806060602080938801015201611230565b73ffffffffffffffffffffffffffffffffffffffff9098959897949392979691966112f46113c2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f551694853b156100e7576040517fef55bec6000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018890526064810193909352608483019390935260a482019790975260ff90961660c487015260e48601919091526101048501525f846101248183855af1938415610a5557610d78946113ac575b50611765565b6113b590610307565b5f6113a6565b156100e757565b60ff5f5416156100e757565b7fffffffff00000000000000000000000000000000000000000000000000000000903581811693926004811061140357505050565b60040360031b82901b16169150565b908160209103126100e7575190565b95949392919061147561147161146a61143a848b6113ce565b7fffffffff00000000000000000000000000000000000000000000000000000000165f52600160205260405f2090565b5460ff1690565b1590565b6115dc576040517f70a082310000000000000000000000000000000000000000000000000000000080825230600483015260209873ffffffffffffffffffffffffffffffffffffffff94919391929091908a816024818c8a165afa948515610a55578b915f966115bd575b5060405190815230600482015295869060249082908d165afa948515610a55576100f89a5f96611584575b50505f61157f92819261153d8661153760035473ffffffffffffffffffffffffffffffffffffffff1690565b8d6118cf565b8261155d60035473ffffffffffffffffffffffffffffffffffffffff1690565b9261156d60405180948193611135565b03925af1611579611142565b506113bb565b6119d9565b5f929650926115ad83928561157f96903d106115b6575b6115a58183610320565b810190611412565b9692509261150b565b503d61159b565b6115d5919650823d84116115b6576115a58183610320565b945f6114e0565b60046040517f42868c9b000000000000000000000000000000000000000000000000000000008152fd5b9290604051927f23b872dd00000000000000000000000000000000000000000000000000000000602085015273ffffffffffffffffffffffffffffffffffffffff809216602485015216604483015260648201526064815260a081019181831067ffffffffffffffff84111761031b576100f892604052611bb0565b3561107c816100c9565b3561107c816102cc565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b9895909461107c9d9b97926020956117579a959c976101809d8d73ffffffffffffffffffffffffffffffffffffffff998a8096818096168452169101521660408d01521660608b015260808a015260a089015260c08801521660e086015263ffffffff8092166101008601521661012084015261014083019063ffffffff169052565b816101608201520191611696565b9190916117948361178e61099760025473ffffffffffffffffffffffffffffffffffffffff1690565b836118cf565b6117b661099760025473ffffffffffffffffffffffffffffffffffffffff1690565b916117c360408201611682565b6117cf60608301611682565b916117d981611682565b936117e660a08301611682565b6117f260c0840161168c565b6117fe60e0850161168c565b9061180c610100860161168c565b9261181b6101208701876110c4565b9690958b3b156100e7576040519c8d9b8c809c7f7b939232000000000000000000000000000000000000000000000000000000008252608086013595602001359473ffffffffffffffffffffffffffffffffffffffff16916004019c6118809d6116d4565b03815a5f948591f18015610a55576118955750565b80610a496100f892610307565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b60449192602073ffffffffffffffffffffffffffffffffffffffff604051948580927fdd62ed3e000000000000000000000000000000000000000000000000000000008252306004830152808916602483015286165afa928315610a55575f936119ab575b5082018092116119a6576040517f095ea7b300000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff9390931660248401526044808401929092529082526100f891906119a1606483610320565b611bb0565b6118a2565b6119c591935060203d6020116115b6576115a58183610320565b915f611934565b919082039182116119a657565b6040517f70a082310000000000000000000000000000000000000000000000000000000080825230600483015273ffffffffffffffffffffffffffffffffffffffff989697959695602095878b16959294939087826024818a5afa8015610a5557611a4b925f91611b93575b506119cc565b978810611b69576040519384523060048501528916928581602481875afa8015610a55578392611a81925f92611b4a57506119cc565b03611b20576100f8977f646284e396b68ff4b4f34e0aa97bcdb9c100f5b44a20da5c475f62703985384191611b18611ace60035473ffffffffffffffffffffffffffffffffffffffff1690565b89611ad88c611682565b9360405195869516998d013592859094939260609273ffffffffffffffffffffffffffffffffffffffff6080840197168352602083015260408201520152565b0390a4611765565b60046040517fd6cf42f0000000000000000000000000000000000000000000000000000000008152fd5b611b62919250883d8a116115b6576115a58183610320565b905f611a45565b60046040517f0492ff87000000000000000000000000000000000000000000000000000000008152fd5b611baa9150893d8b116115b6576115a58183610320565b5f611a45565b73ffffffffffffffffffffffffffffffffffffffff166040516040810181811067ffffffffffffffff82111761031b57611c2b937f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656460205f948594604052818152015260208151910182855af1611c25611142565b91611c64565b8051908115918215611c41575b5050156100e757565b81925090602091810103126100e7576020015180151581036100e7575f80611c38565b9015611c7e57815115611c75575090565b3b156100e75790565b5080519081156100e757602001fdfea2646970667358221220273204c702747fdff0ffe95c6319ba2f475d4a21c4beb991049bd8c21271b20064736f6c63430008170033",
  "deployedBytecode": "0x60806040526004361015610011575f80fd5b5f3560e01c8063038f12ea146100c4578063277deffe146100bf57806327e98fbd146100ba57806385f168eb146100b5578063ac9650d8146100b0578063afdac3d6146100ab578063bdf52ad3146100a6578063c0c53b8b146100a1578063c51e5eb91461009c578063d2f7265a146100975763fdf152d314610092575f80fd5b610b13565b610ac2565b6108a0565b61074d565b6106c0565b61066f565b6105dd565b610481565b61039b565b610224565b610175565b73ffffffffffffffffffffffffffffffffffffffff8116036100e757565b5f80fd5b600435906100f8826100c9565b565b602435906100f8826100c9565b9181601f840112156100e75782359167ffffffffffffffff83116100e757602083818601950101116100e757565b90816101409103126100e75790565b610124359060ff821682036100e757565b60e4359060ff821682036100e757565b6084359060ff821682036100e757565b346100e7576101807ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576101ad6100eb565b6101b56100fa565b67ffffffffffffffff91906044358381116100e7576101d8903690600401610107565b9260a4359485116100e7576101f4610222953690600401610135565b936101fd610144565b9261016435956101443595610104359460e4359460c435946084359360643593610c95565b005b346100e7576101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757600435610260816100c9565b6102686100fa565b67ffffffffffffffff91906044358381116100e75761028b903690600401610107565b919060a4359485116100e7576102a8610222953690600401610135565b6102b0610155565b926101243595610104359560c435946084359360643593610dc0565b63ffffffff8116036100e757565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52604160045260245ffd5b67ffffffffffffffff811161031b57604052565b6102da565b90601f7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0910116810190811067ffffffffffffffff82111761031b57604052565b67ffffffffffffffff811161031b57601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe01660200190565b6101407ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576004356103d2816100c9565b6024356103de816100c9565b60a4356103ea816100c9565b60c4356103f6816102cc565b60e43590610403826102cc565b6101043592610411846102cc565b610124359567ffffffffffffffff87116100e757366023880112156100e75786600401359561043f87610361565b9661044d6040519889610320565b808852366024828b0101116100e7576020815f9260246102229c01838c013789010152608435916064359160443591610ea0565b346100e75760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576004357fffffffff0000000000000000000000000000000000000000000000000000000081168091036100e7575f526001602052602060ff60405f2054166040519015158152f35b5f5b8381106105095750505f910152565b81810151838201526020016104fa565b907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f602093610555815180928187528780880191016104f8565b0116010190565b6020808201906020835283518092526040830192602060408460051b8301019501935f915b8483106105915750505050505090565b90919293949584806105cd837fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc086600196030187528a51610519565b9801930193019194939290610581565b346100e75760207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e75767ffffffffffffffff6004358181116100e757366023820112156100e75780600401359182116100e7573660248360051b830101116100e75761066191602461065592016111e4565b6040519182918261055c565b0390f35b5f9103126100e757565b346100e7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757602073ffffffffffffffffffffffffffffffffffffffff60025416604051908152f35b346100e7576101207ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e7576004356106fc816100c9565b60443567ffffffffffffffff81116100e75761071c903690600401610135565b9060c4359160ff831683036100e75761022292610104359260e4359260a435916084359160643591602435906112cb565b346100e75760607ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757600435610788816100c9565b60243590610795826100c9565b604435906107a2826100c9565b60045460ff8160a01c16610876577fffffffffffffffffffffff00000000000000000000000000000000000000000074010000000000000000000000000000000000000000926102229573ffffffffffffffffffffffffffffffffffffffff8092167fffffffffffffffffffffffff00000000000000000000000000000000000000006002541617600255169116171760045573ffffffffffffffffffffffffffffffffffffffff167fffffffffffffffffffffffff00000000000000000000000000000000000000006003541617600355565b60046040517f9f4eefba000000000000000000000000000000000000000000000000000000008152fd5b60c07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757600480356108d7816100c9565b602435906108e4826100c9565b67ffffffffffffffff6044358181116100e7576109049036908601610107565b916064359060a4359081116100e7576109209036908801610135565b926109296113c2565b6109547fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f55565b3415610aac57813403610a835773ffffffffffffffffffffffffffffffffffffffff6109b0610997895473ffffffffffffffffffffffffffffffffffffffff1690565b73ffffffffffffffffffffffffffffffffffffffff1690565b9080821690871603610a5a57803b156100e7575f90604051988980927fd0e30db000000000000000000000000000000000000000000000000000000000825234905af1968715610a5557610a0e97610a3c575b505b60843592611421565b61022260017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b80610a49610a4f92610307565b80610665565b5f610a03565b610db5565b876040517f3539a701000000000000000000000000000000000000000000000000000000008152fd5b866040517f1841b4e1000000000000000000000000000000000000000000000000000000008152fd5b610a0e9650610abd82303388611606565b610a05565b346100e7575f7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e757602073ffffffffffffffffffffffffffffffffffffffff60035416604051908152f35b346100e7575f60e07ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3601126100e75760043590610b50826100c9565b60243560443567ffffffffffffffff81116100e757610b73903690600401610135565b9073ffffffffffffffffffffffffffffffffffffffff610b91610165565b94610b9a6113c2565b610bc57fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f55565b1693843b156100e7576040517fd505accf00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101839052606480359082015260ff91909116608482015260a480359082015260c48035908201525f8160e48183895af1610c80575b50610c4f9293610c4a82303384611606565b611765565b610c7d60017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b80f35b610c4f9350610c8e90610307565b5f92610c38565b73ffffffffffffffffffffffffffffffffffffffff909c9a919b94979295989396999c610cc06113c2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f5516998a3b156100e7576040517fef55bec6000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018990526064810193909352608483019390935260a482019b909b5260ff909a1660c48b015260e48a01919091526101048901525f8861012481838a5af1978815610a5557610d7898610da6575b50611421565b6100f860017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b610daf90610307565b5f610d72565b6040513d5f823e3d90fd5b73ffffffffffffffffffffffffffffffffffffffff909a91999293949596979a610de86113c2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f551697883b156100e7576040517fd505accf00000000000000000000000000000000000000000000000000000000815233600482015230602482015260448101879052606481019b909b5260ff1660848b015260a48a019190915260c4890152610d78975f8160e481838b5af1610e91575b50610e8c83303389611606565b611421565b610e9a90610307565b5f610e7f565b939298919697909497610eb16113c2565b610edc7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f55565b873403610fce57610f0561099760025473ffffffffffffffffffffffffffffffffffffffff1690565b96873b15610fa457873b156100e7575f99610f51956040519c8d9b8c9a8b9a7f7b939232000000000000000000000000000000000000000000000000000000008c523360048d01610ff8565b039134905af18015610a5557610f91575b506100f860017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f5416175f55565b80610a49610f9e92610307565b5f610f62565b60046040517fb474246c000000000000000000000000000000000000000000000000000000008152fd5b60046040517f1841b4e1000000000000000000000000000000000000000000000000000000008152fd5b9794909361107c9b9a969294999793996101809a73ffffffffffffffffffffffffffffffffffffffff8097818094168d521660208c01521660408a01525f60608a0152608089015260a088015260c08701521660e085015263ffffffff92838092166101008601521661012084015216610140820152816101608201520190610519565b90565b67ffffffffffffffff811161031b5760051b60200190565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52603260045260245ffd5b9035907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1813603018212156100e7570180359067ffffffffffffffff82116100e7576020019181360383136100e757565b908210156111305761112c9160051b8101906110c4565b9091565b611097565b908092918237015f815290565b3d1561116c573d9061115382610361565b916111616040519384610320565b82523d5f602084013e565b606090565b6020818303126100e75780519067ffffffffffffffff82116100e7570181601f820112156100e75780516111a481610361565b926111b26040519485610320565b818452602082840101116100e75761107c91602080850191016104f8565b80518210156111305760209160051b010190565b9190916111f08361107f565b9060406112006040519384610320565b8483527fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe061122d8661107f565b015f5b8181106112ba57505082945f5b81811061124b575050505050565b5f80611258838588611115565b90611267875180938193611135565b0390305af4611274611142565b901561129a579060019161128882886111d0565b5261129381876111d0565b500161123d565b60448151106100e7578060046100e7920151602480918301019101611171565b806060602080938801015201611230565b73ffffffffffffffffffffffffffffffffffffffff9098959897949392979691966112f46113c2565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff005f54165f551694853b156100e7576040517fef55bec6000000000000000000000000000000000000000000000000000000008152336004820152306024820152604481018890526064810193909352608483019390935260a482019790975260ff90961660c487015260e48601919091526101048501525f846101248183855af1938415610a5557610d78946113ac575b50611765565b6113b590610307565b5f6113a6565b156100e757565b60ff5f5416156100e757565b7fffffffff00000000000000000000000000000000000000000000000000000000903581811693926004811061140357505050565b60040360031b82901b16169150565b908160209103126100e7575190565b95949392919061147561147161146a61143a848b6113ce565b7fffffffff00000000000000000000000000000000000000000000000000000000165f52600160205260405f2090565b5460ff1690565b1590565b6115dc576040517f70a082310000000000000000000000000000000000000000000000000000000080825230600483015260209873ffffffffffffffffffffffffffffffffffffffff94919391929091908a816024818c8a165afa948515610a55578b915f966115bd575b5060405190815230600482015295869060249082908d165afa948515610a55576100f89a5f96611584575b50505f61157f92819261153d8661153760035473ffffffffffffffffffffffffffffffffffffffff1690565b8d6118cf565b8261155d60035473ffffffffffffffffffffffffffffffffffffffff1690565b9261156d60405180948193611135565b03925af1611579611142565b506113bb565b6119d9565b5f929650926115ad83928561157f96903d106115b6575b6115a58183610320565b810190611412565b9692509261150b565b503d61159b565b6115d5919650823d84116115b6576115a58183610320565b945f6114e0565b60046040517f42868c9b000000000000000000000000000000000000000000000000000000008152fd5b9290604051927f23b872dd00000000000000000000000000000000000000000000000000000000602085015273ffffffffffffffffffffffffffffffffffffffff809216602485015216604483015260648201526064815260a081019181831067ffffffffffffffff84111761031b576100f892604052611bb0565b3561107c816100c9565b3561107c816102cc565b601f82602094937fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe093818652868601375f8582860101520116010190565b9895909461107c9d9b97926020956117579a959c976101809d8d73ffffffffffffffffffffffffffffffffffffffff998a8096818096168452169101521660408d01521660608b015260808a015260a089015260c08801521660e086015263ffffffff8092166101008601521661012084015261014083019063ffffffff169052565b816101608201520191611696565b9190916117948361178e61099760025473ffffffffffffffffffffffffffffffffffffffff1690565b836118cf565b6117b661099760025473ffffffffffffffffffffffffffffffffffffffff1690565b916117c360408201611682565b6117cf60608301611682565b916117d981611682565b936117e660a08301611682565b6117f260c0840161168c565b6117fe60e0850161168c565b9061180c610100860161168c565b9261181b6101208701876110c4565b9690958b3b156100e7576040519c8d9b8c809c7f7b939232000000000000000000000000000000000000000000000000000000008252608086013595602001359473ffffffffffffffffffffffffffffffffffffffff16916004019c6118809d6116d4565b03815a5f948591f18015610a55576118955750565b80610a496100f892610307565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b60449192602073ffffffffffffffffffffffffffffffffffffffff604051948580927fdd62ed3e000000000000000000000000000000000000000000000000000000008252306004830152808916602483015286165afa928315610a55575f936119ab575b5082018092116119a6576040517f095ea7b300000000000000000000000000000000000000000000000000000000602082015273ffffffffffffffffffffffffffffffffffffffff9390931660248401526044808401929092529082526100f891906119a1606483610320565b611bb0565b6118a2565b6119c591935060203d6020116115b6576115a58183610320565b915f611934565b919082039182116119a657565b6040517f70a082310000000000000000000000000000000000000000000000000000000080825230600483015273ffffffffffffffffffffffffffffffffffffffff989697959695602095878b16959294939087826024818a5afa8015610a5557611a4b925f91611b93575b506119cc565b978810611b69576040519384523060048501528916928581602481875afa8015610a55578392611a81925f92611b4a57506119cc565b03611b20576100f8977f646284e396b68ff4b4f34e0aa97bcdb9c100f5b44a20da5c475f62703985384191611b18611ace60035473ffffffffffffffffffffffffffffffffffffffff1690565b89611ad88c611682565b9360405195869516998d013592859094939260609273ffffffffffffffffffffffffffffffffffffffff6080840197168352602083015260408201520152565b0390a4611765565b60046040517fd6cf42f0000000000000000000000000000000000000000000000000000000008152fd5b611b62919250883d8a116115b6576115a58183610320565b905f611a45565b60046040517f0492ff87000000000000000000000000000000000000000000000000000000008152fd5b611baa9150893d8b116115b6576115a58183610320565b5f611a45565b73ffffffffffffffffffffffffffffffffffffffff166040516040810181811067ffffffffffffffff82111761031b57611c2b937f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c656460205f948594604052818152015260208151910182855af1611c25611142565b91611c64565b8051908115918215611c41575b5050156100e757565b81925090602091810103126100e7576020015180151581036100e7575f80611c38565b9015611c7e57815115611c75575090565b3b156100e75790565b5080519081156100e757602001fdfea2646970667358221220273204c702747fdff0ffe95c6319ba2f475d4a21c4beb991049bd8c21271b20064736f6c63430008170033",
  "devdoc": {
    "custom:security-contact": "bugs@across.to",
    "details": "Variables which may be immutable are not marked as immutable, nor defined in the constructor, so that this contract may be deployed deterministically.",
    "kind": "dev",
    "methods": {
      "constructor": {
        "params": {
          "_allowedSelectors": "Function selectors that are allowed to be called on the exchange."
        }
      },
      "deposit(address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)": {
        "details": "Protects the caller from losing their ETH (or other native token) by reverting if the SpokePool address they intended to call does not exist on this chain. Because this contract can be deployed at the same address everywhere callers should be protected even if the transaction is submitted to an unintended network. This contract should only be used for native token deposits, as this problem only exists for native tokens.",
        "params": {
          "destinationChainId": "Denotes network where user will receive funds from SpokePool by a relayer.",
          "exclusiveRelayer": "Address of the relayer who has exclusive rights to fill this deposit. Can be set to 0x0 if no period is desired. If so, then must set exclusivityParameter to 0.",
          "exclusivityParameter": "Timestamp or offset, after which any relayer can fill this deposit. Must set to 0 if exclusiveRelayer is set to 0x0, and vice versa.",
          "fillDeadline": "Timestamp after which this deposit can no longer be filled.",
          "inputAmount": "Amount of tokens to deposit.",
          "inputToken": "Token to lock into this contract to initiate deposit.",
          "message": "Arbitrary data that can be used to pass additional information to the recipient along with the tokens. Note: this is intended to be used to pass along instructions for how a contract should use or allocate the tokens.",
          "outputAmount": "Amount of tokens to receive on destination chain.",
          "quoteTimestamp": "Timestamp used by relayers to compute this deposit's realizedLPFeePct which is paid to LP pool on HubPool.",
          "recipient": "Address to receive funds at on destination chain."
        }
      },
      "depositWithAuthorization(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)": {
        "details": "If `acrossInputToken` does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.",
        "params": {
          "acrossInputAmount": "Amount of the input token to deposit.",
          "acrossInputToken": "EIP-3009 compliant token to deposit.",
          "depositData": "Specifies the Across deposit params to send.",
          "nonce": "Unique nonce used in the `receiveWithAuthorization` signature.",
          "r": "r of the EIP-3009 signature.",
          "s": "s of the EIP-3009 signature.",
          "v": "v of the EIP-3009 signature.",
          "validAfter": "The unix time after which the `receiveWithAuthorization` signature is valid.",
          "validBefore": "The unix time before which the `receiveWithAuthorization` signature is valid."
        }
      },
      "depositWithPermit(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)": {
        "details": "If `acrossInputToken` does not implement `permit` to the specifications of EIP-2612, this function will fail.",
        "params": {
          "acrossInputAmount": "Amount of the input token to deposit.",
          "acrossInputToken": "EIP-2612 compliant token to deposit.",
          "deadline": "Deadline before which the permit signature is valid.",
          "depositData": "Specifies the Across deposit params to send.",
          "r": "r of the permit signature.",
          "s": "s of the permit signature.",
          "v": "v of the permit signature."
        }
      },
      "initialize(address,address,address)": {
        "details": "These values are initialized in a function and not in the constructor so that the creation code of this contract is the same across networks with different addresses for the wrapped native token, the exchange this contract uses to swap and bridge, and this network's corresponding spoke pool contract. This is to allow this contract to be deterministically deployed with CREATE2.This function can be front-run by anybody, so it is critical to check that the `spokePool`, `wrappedNativeToken`, and `exchange` values used in the single call to this function were passed in correctly before enabling the usage of this contract.",
        "params": {
          "_exchange": "Address of the exchange where tokens will be swapped.",
          "_spokePool": "Address of the SpokePool contract that we'll submit deposits to.",
          "_wrappedNativeToken": "Address of the wrapped native token for the network this contract is deployed to."
        }
      },
      "swapAndBridge(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes))": {
        "details": "If swapToken or acrossInputToken are the native token for this chain then this function might fail. the assumption is that this function will handle only ERC20 tokens.",
        "params": {
          "acrossInputToken": "Address of the token that will be bridged via Across as the inputToken.",
          "depositData": "Specifies the Across deposit params we'll send after the swap.",
          "minExpectedInputTokenAmount": "Minimum amount of received depositData.inputToken that we'll submit bridge deposit with.",
          "routerCalldata": "ABI encoded function data to call on router. Should form a swap of swapToken for enough of acrossInputToken, otherwise this function will revert.",
          "swapToken": "Address of the token that will be swapped for acrossInputToken.",
          "swapTokenAmount": "Amount of swapToken to swap for a minimum amount of depositData.inputToken."
        }
      },
      "swapAndBridgeWithAuthorization(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)": {
        "details": "If swapToken does not implement `receiveWithAuthorization` to the specifications of EIP-3009, this call will revert.",
        "params": {
          "acrossInputToken": "Address of the token that will be bridged via Across as the inputToken.",
          "depositData": "Specifies the Across deposit params we'll send after the swap.",
          "minExpectedInputTokenAmount": "Minimum amount of received depositData.inputToken that we'll submit bridge deposit with.",
          "nonce": "Unique nonce used in the `receiveWithAuthorization` signature.",
          "r": "r of the EIP-3009 signature.",
          "routerCalldata": "ABI encoded function data to call on router. Should form a swap of swapToken for enough of acrossInputToken, otherwise this function will revert.",
          "s": "s of the EIP-3009 signature.",
          "swapToken": "Address of the token that will be swapped for acrossInputToken.",
          "swapTokenAmount": "Amount of swapToken to swap for a minimum amount of depositData.inputToken.",
          "v": "v of the EIP-3009 signature.",
          "validAfter": "The unix time after which the `receiveWithAuthorization` signature is valid.",
          "validBefore": "The unix time before which the `receiveWithAuthorization` signature is valid."
        }
      },
      "swapAndBridgeWithPermit(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)": {
        "details": "If swapToken does not implement `permit` to the specifications of EIP-2612, this function will fail.",
        "params": {
          "acrossInputToken": "Address of the token that will be bridged via Across as the inputToken.",
          "deadline": "Deadline before which the permit signature is valid.",
          "depositData": "Specifies the Across deposit params we'll send after the swap.",
          "minExpectedInputTokenAmount": "Minimum amount of received depositData.inputToken that we'll submit bridge deposit with.",
          "r": "r of the permit signature.",
          "routerCalldata": "ABI encoded function data to call on router. Should form a swap of swapToken for enough of acrossInputToken, otherwise this function will revert.",
          "s": "s of the permit signature.",
          "swapToken": "Address of the token that will be swapped for acrossInputToken.",
          "swapTokenAmount": "Amount of swapToken to swap for a minimum amount of depositData.inputToken.",
          "v": "v of the permit signature."
        }
      }
    },
    "title": "SpokePoolV3Periphery",
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "constructor": {
        "notice": "Construct a new SwapAndBridgeBase contract."
      },
      "deposit(address,address,uint256,uint256,uint256,address,uint32,uint32,uint32,bytes)": {
        "notice": "Passthrough function to `depositV3()` on the SpokePool contract."
      },
      "depositWithAuthorization(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)": {
        "notice": "Deposits an EIP-3009 compliant Across input token into the Spoke Pool contract."
      },
      "depositWithPermit(address,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)": {
        "notice": "Deposits an EIP-2612 token Across input token into the Spoke Pool contract."
      },
      "initialize(address,address,address)": {
        "notice": "Initializes the SwapAndBridgeBase contract."
      },
      "swapAndBridge(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes))": {
        "notice": "Swaps tokens on this chain via specified router before submitting Across deposit atomically. Caller can specify their slippage tolerance for the swap and Across deposit params."
      },
      "swapAndBridgeWithAuthorization(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint256,bytes32,uint8,bytes32,bytes32)": {
        "notice": "Swaps an EIP-3009 token on this chain via specified router before submitting Across deposit atomically. Caller can specify their slippage tolerance for the swap and Across deposit params."
      },
      "swapAndBridgeWithPermit(address,address,bytes,uint256,uint256,(address,uint256,address,address,uint256,address,uint32,uint32,uint32,bytes),uint256,uint8,bytes32,bytes32)": {
        "notice": "Swaps an EIP-2612 token on this chain via specified router before submitting Across deposit atomically. Caller can specify their slippage tolerance for the swap and Across deposit params."
      }
    },
    "notice": "Contract for performing more complex interactions with an AcrossV3 spoke pool deployment.",
    "version": 1
  },
  "storageLayout": {
    "storage": [
      {
        "astId": 17765,
        "contract": "contracts/SpokePoolV3Periphery.sol:SpokePoolV3Periphery",
        "label": "_notEntered",
        "offset": 0,
        "slot": "0",
        "type": "t_bool"
      },
      {
        "astId": 22166,
        "contract": "contracts/SpokePoolV3Periphery.sol:SpokePoolV3Periphery",
        "label": "allowedSelectors",
        "offset": 0,
        "slot": "1",
        "type": "t_mapping(t_bytes4,t_bool)"
      },
      {
        "astId": 22169,
        "contract": "contracts/SpokePoolV3Periphery.sol:SpokePoolV3Periphery",
        "label": "spokePool",
        "offset": 0,
        "slot": "2",
        "type": "t_contract(V3SpokePoolInterface)34772"
      },
      {
        "astId": 22171,
        "contract": "contracts/SpokePoolV3Periphery.sol:SpokePoolV3Periphery",
        "label": "exchange",
        "offset": 0,
        "slot": "3",
        "type": "t_address"
      },
      {
        "astId": 22174,
        "contract": "contracts/SpokePoolV3Periphery.sol:SpokePoolV3Periphery",
        "label": "wrappedNativeToken",
        "offset": 0,
        "slot": "4",
        "type": "t_contract(WETH9Interface)33559"
      },
      {
        "astId": 22176,
        "contract": "contracts/SpokePoolV3Periphery.sol:SpokePoolV3Periphery",
        "label": "initialized",
        "offset": 20,
        "slot": "4",
        "type": "t_bool"
      }
    ],
    "types": {
      "t_address": {
        "encoding": "inplace",
        "label": "address",
        "numberOfBytes": "20"
      },
      "t_bool": {
        "encoding": "inplace",
        "label": "bool",
        "numberOfBytes": "1"
      },
      "t_bytes4": {
        "encoding": "inplace",
        "label": "bytes4",
        "numberOfBytes": "4"
      },
      "t_contract(V3SpokePoolInterface)34772": {
        "encoding": "inplace",
        "label": "contract V3SpokePoolInterface",
        "numberOfBytes": "20"
      },
      "t_contract(WETH9Interface)33559": {
        "encoding": "inplace",
        "label": "contract WETH9Interface",
        "numberOfBytes": "20"
      },
      "t_mapping(t_bytes4,t_bool)": {
        "encoding": "mapping",
        "key": "t_bytes4",
        "label": "mapping(bytes4 => bool)",
        "numberOfBytes": "32",
        "value": "t_bool"
      }
    }
  }
}
