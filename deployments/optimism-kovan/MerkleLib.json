{
  "address": "0xFB87Ac52Bac7ccF497b6053610A9c59B87a0cE7D",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "claimedBitMap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "isClaimed1D",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "claimedBitMap",
          "type": "uint256"
        },
        {
          "internalType": "uint256",
          "name": "index",
          "type": "uint256"
        }
      ],
      "name": "setClaimed1D",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "bundleLpFees",
              "type": "uint256[]"
            },
            {
              "internalType": "int256[]",
              "name": "netSendAmounts",
              "type": "int256[]"
            },
            {
              "internalType": "int256[]",
              "name": "runningBalances",
              "type": "int256[]"
            },
            {
              "internalType": "uint8",
              "name": "leafId",
              "type": "uint8"
            },
            {
              "internalType": "address[]",
              "name": "l1Tokens",
              "type": "address[]"
            }
          ],
          "internalType": "struct HubPoolInterface.PoolRebalanceLeaf",
          "name": "rebalance",
          "type": "tuple"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "verifyPoolRebalance",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "uint256",
              "name": "amountToReturn",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "chainId",
              "type": "uint256"
            },
            {
              "internalType": "uint256[]",
              "name": "refundAmounts",
              "type": "uint256[]"
            },
            {
              "internalType": "uint32",
              "name": "leafId",
              "type": "uint32"
            },
            {
              "internalType": "address",
              "name": "l2TokenAddress",
              "type": "address"
            },
            {
              "internalType": "address[]",
              "name": "refundAddresses",
              "type": "address[]"
            }
          ],
          "internalType": "struct SpokePoolInterface.DestinationDistributionLeaf",
          "name": "distribution",
          "type": "tuple"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "verifyRelayerDistribution",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes32",
          "name": "root",
          "type": "bytes32"
        },
        {
          "components": [
            {
              "internalType": "address",
              "name": "depositor",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "recipient",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "destinationToken",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "relayAmount",
              "type": "uint256"
            },
            {
              "internalType": "uint256",
              "name": "originChainId",
              "type": "uint256"
            },
            {
              "internalType": "uint64",
              "name": "realizedLpFeePct",
              "type": "uint64"
            },
            {
              "internalType": "uint64",
              "name": "relayerFeePct",
              "type": "uint64"
            },
            {
              "internalType": "uint32",
              "name": "depositId",
              "type": "uint32"
            }
          ],
          "internalType": "struct SpokePoolInterface.RelayData",
          "name": "slowRelayFulfillment",
          "type": "tuple"
        },
        {
          "internalType": "bytes32[]",
          "name": "proof",
          "type": "bytes32[]"
        }
      ],
      "name": "verifySlowRelayFulfillment",
      "outputs": [
        {
          "internalType": "bool",
          "name": "",
          "type": "bool"
        }
      ],
      "stateMutability": "pure",
      "type": "function"
    }
  ],
  "transactionHash": "0x0385e9babb19f4434f3eb74f28fd6bbbe40191a6aa2c86e8cb4b6dfb78e00e6c",
  "receipt": {
    "to": null,
    "from": "0x9A8f92a830A5cB89a3816e3D267CB7791c16b04D",
    "contractAddress": "0xFB87Ac52Bac7ccF497b6053610A9c59B87a0cE7D",
    "transactionIndex": 0,
    "gasUsed": "713521",
    "logsBloom": "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "blockHash": "0x9ed117537e479d235eaa8c9cec55d63e3f09a04d63c58504af828fcff838a767",
    "transactionHash": "0x0385e9babb19f4434f3eb74f28fd6bbbe40191a6aa2c86e8cb4b6dfb78e00e6c",
    "logs": [],
    "blockNumber": 1197004,
    "cumulativeGasUsed": "713521",
    "status": 1,
    "byzantium": true
  },
  "args": [],
  "numDeployments": 1,
  "solcInputHash": "a8ba4a0874b41d84e42606c001695699",
  "metadata": "{\"compiler\":{\"version\":\"0.8.11+commit.d7f03943\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedBitMap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"isClaimed1D\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"claimedBitMap\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"setClaimed1D\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"\",\"type\":\"uint256\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"bundleLpFees\",\"type\":\"uint256[]\"},{\"internalType\":\"int256[]\",\"name\":\"netSendAmounts\",\"type\":\"int256[]\"},{\"internalType\":\"int256[]\",\"name\":\"runningBalances\",\"type\":\"int256[]\"},{\"internalType\":\"uint8\",\"name\":\"leafId\",\"type\":\"uint8\"},{\"internalType\":\"address[]\",\"name\":\"l1Tokens\",\"type\":\"address[]\"}],\"internalType\":\"struct HubPoolInterface.PoolRebalanceLeaf\",\"name\":\"rebalance\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyPoolRebalance\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"uint256\",\"name\":\"amountToReturn\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"chainId\",\"type\":\"uint256\"},{\"internalType\":\"uint256[]\",\"name\":\"refundAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"uint32\",\"name\":\"leafId\",\"type\":\"uint32\"},{\"internalType\":\"address\",\"name\":\"l2TokenAddress\",\"type\":\"address\"},{\"internalType\":\"address[]\",\"name\":\"refundAddresses\",\"type\":\"address[]\"}],\"internalType\":\"struct SpokePoolInterface.DestinationDistributionLeaf\",\"name\":\"distribution\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifyRelayerDistribution\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes32\",\"name\":\"root\",\"type\":\"bytes32\"},{\"components\":[{\"internalType\":\"address\",\"name\":\"depositor\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"recipient\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"destinationToken\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"relayAmount\",\"type\":\"uint256\"},{\"internalType\":\"uint256\",\"name\":\"originChainId\",\"type\":\"uint256\"},{\"internalType\":\"uint64\",\"name\":\"realizedLpFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint64\",\"name\":\"relayerFeePct\",\"type\":\"uint64\"},{\"internalType\":\"uint32\",\"name\":\"depositId\",\"type\":\"uint32\"}],\"internalType\":\"struct SpokePoolInterface.RelayData\",\"name\":\"slowRelayFulfillment\",\"type\":\"tuple\"},{\"internalType\":\"bytes32[]\",\"name\":\"proof\",\"type\":\"bytes32[]\"}],\"name\":\"verifySlowRelayFulfillment\",\"outputs\":[{\"internalType\":\"bool\",\"name\":\"\",\"type\":\"bool\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"isClaimed(mapping(uint256 => uint256) storage,uint256)\":{\"params\":{\"claimedBitMap\":\"a simple uint256 mapping in storage used as a bitmap.\",\"index\":\"the index to check in the bitmap.\"},\"returns\":{\"_0\":\"bool indicating if the index within the claimedBitMap has been marked as claimed.\"}},\"isClaimed1D(uint256,uint256)\":{\"params\":{\"claimedBitMap\":\"a simple uint256 value, encoding a 1D bitmap.\",\"index\":\"the index to check in the bitmap.\"},\"returns\":{\"_0\":\"bool indicating if the index within the claimedBitMap has been marked as claimed.\"}},\"setClaimed(mapping(uint256 => uint256) storage,uint256)\":{\"params\":{\"claimedBitMap\":\"a simple uint256 mapping in storage used as a bitmap.\",\"index\":\"the index to mark in the bitmap.\"}},\"setClaimed1D(uint256,uint256)\":{\"params\":{\"claimedBitMap\":\"a simple uint256 mapping in storage used as a bitmap.\",\"index\":\"the index to mark in the bitmap.\"}},\"verifyPoolRebalance(bytes32,HubPoolInterface.PoolRebalanceLeaf,bytes32[])\":{\"params\":{\"proof\":\"the merkle proof.\",\"rebalance\":\"the rebalance struct.\",\"root\":\"the merkle root.\"}},\"verifyRelayerDistribution(bytes32,SpokePoolInterface.DestinationDistributionLeaf,bytes32[])\":{\"params\":{\"distribution\":\"the distribution struct.\",\"proof\":\"the merkle proof.\",\"root\":\"the merkle root.\"}},\"verifySlowRelayFulfillment(bytes32,SpokePoolInterface.RelayData,bytes32[])\":{\"params\":{\"proof\":\"the merkle proof.\",\"root\":\"the merkle root.\",\"slowRelayFulfillment\":\"the relayData fulfullment struct.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"isClaimed(mapping(uint256 => uint256) storage,uint256)\":{\"notice\":\"Tests whether a claim is contained within a claimedBitMap mapping.\"},\"isClaimed1D(uint256,uint256)\":{\"notice\":\"Tests whether a claim is contained within a 1D claimedBitMap mapping.\"},\"setClaimed(mapping(uint256 => uint256) storage,uint256)\":{\"notice\":\"Marks an index in a claimedBitMap as claimed.\"},\"setClaimed1D(uint256,uint256)\":{\"notice\":\"Marks an index in a claimedBitMap as claimed.\"},\"verifyPoolRebalance(bytes32,HubPoolInterface.PoolRebalanceLeaf,bytes32[])\":{\"notice\":\"Verifies that a repayment is contained within a merkle root.\"},\"verifyRelayerDistribution(bytes32,SpokePoolInterface.DestinationDistributionLeaf,bytes32[])\":{\"notice\":\"Verifies that a distribution is contained within a merkle root.\"},\"verifySlowRelayFulfillment(bytes32,SpokePoolInterface.RelayData,bytes32[])\":{\"notice\":\"Verifies that a distribution is contained within a merkle root.\"}},\"notice\":\"Library to help with merkle roots, proofs, and claims.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/MerkleLib.sol\":\"MerkleLib\"},\"evmVersion\":\"london\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@openzeppelin/contracts/token/ERC20/IERC20.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev Interface of the ERC20 standard as defined in the EIP.\\n */\\ninterface IERC20 {\\n    /**\\n     * @dev Returns the amount of tokens in existence.\\n     */\\n    function totalSupply() external view returns (uint256);\\n\\n    /**\\n     * @dev Returns the amount of tokens owned by `account`.\\n     */\\n    function balanceOf(address account) external view returns (uint256);\\n\\n    /**\\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transfer(address recipient, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Returns the remaining number of tokens that `spender` will be\\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\\n     * zero by default.\\n     *\\n     * This value changes when {approve} or {transferFrom} are called.\\n     */\\n    function allowance(address owner, address spender) external view returns (uint256);\\n\\n    /**\\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\\n     * that someone may use both the old and the new allowance by unfortunate\\n     * transaction ordering. One possible solution to mitigate this race\\n     * condition is to first reduce the spender's allowance to 0 and set the\\n     * desired value afterwards:\\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\\n     *\\n     * Emits an {Approval} event.\\n     */\\n    function approve(address spender, uint256 amount) external returns (bool);\\n\\n    /**\\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\\n     * allowance mechanism. `amount` is then deducted from the caller's\\n     * allowance.\\n     *\\n     * Returns a boolean value indicating whether the operation succeeded.\\n     *\\n     * Emits a {Transfer} event.\\n     */\\n    function transferFrom(\\n        address sender,\\n        address recipient,\\n        uint256 amount\\n    ) external returns (bool);\\n\\n    /**\\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\\n     * another (`to`).\\n     *\\n     * Note that `value` may be zero.\\n     */\\n    event Transfer(address indexed from, address indexed to, uint256 value);\\n\\n    /**\\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\\n     * a call to {approve}. `value` is the new allowance.\\n     */\\n    event Approval(address indexed owner, address indexed spender, uint256 value);\\n}\\n\",\"keccak256\":\"0x61437cb513a887a1bbad006e7b1c8b414478427d33de47c5600af3c748f108da\",\"license\":\"MIT\"},\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\\n\\npragma solidity ^0.8.0;\\n\\n/**\\n * @dev These functions deal with verification of Merkle Trees proofs.\\n *\\n * The proofs can be generated using the JavaScript library\\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\\n *\\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\\n */\\nlibrary MerkleProof {\\n    /**\\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\\n     * defined by `root`. For this, a `proof` must be provided, containing\\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\\n     */\\n    function verify(\\n        bytes32[] memory proof,\\n        bytes32 root,\\n        bytes32 leaf\\n    ) internal pure returns (bool) {\\n        return processProof(proof, leaf) == root;\\n    }\\n\\n    /**\\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\\n     * hash matches the root of the tree. When processing the proof, the pairs\\n     * of leafs & pre-images are assumed to be sorted.\\n     *\\n     * _Available since v4.4._\\n     */\\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\\n        bytes32 computedHash = leaf;\\n        for (uint256 i = 0; i < proof.length; i++) {\\n            bytes32 proofElement = proof[i];\\n            if (computedHash <= proofElement) {\\n                // Hash(current computed hash + current element of the proof)\\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\\n            } else {\\n                // Hash(current element of the proof + current computed hash)\\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\\n            }\\n        }\\n        return computedHash;\\n    }\\n}\\n\",\"keccak256\":\"0x9c35727c74a6ffd8d02237b414e7bfb532c0323b1088709def98ea5c628157de\",\"license\":\"MIT\"},\"contracts/HubPoolInterface.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/token/ERC20/IERC20.sol\\\";\\nimport \\\"./interfaces/AdapterInterface.sol\\\";\\n\\ninterface HubPoolInterface {\\n    struct PoolRebalanceLeaf {\\n        // This is used to know which chain to send cross-chain transactions to (and which SpokePool to sent to).\\n        uint256 chainId;\\n        uint256[] bundleLpFees; // Total LP fee amount per token in this bundle, encompassing all associated bundled relays.\\n        // This array is grouped with the two above, and it represents the amount to send or request back from the\\n        // SpokePool. If positive, the pool will pay the SpokePool. If negative the SpokePool will pay the HubPool.\\n        // There can be arbitrarily complex rebalancing rules defined offchain. This number is only nonzero\\n        // when the rules indicate that a rebalancing action should occur. When a rebalance does not occur,\\n        // runningBalances for this token should change by the total relays - deposits in this bundle. When a rebalance\\n        // does occur, runningBalances should be set to zero for this token and the netSendAmounts should be set to the\\n        // previous runningBalances + relays - deposits in this bundle.\\n        int256[] netSendAmounts;\\n        // This is only here to be emitted in an event to track a running unpaid balance between the L2 pool and the L1 pool.\\n        // A positive number indicates that the HubPool owes the SpokePool funds. A negative number indicates that the\\n        // SpokePool owes the HubPool funds. See the comment above for the dynamics of this and netSendAmounts\\n        int256[] runningBalances;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint8 leafId;\\n        // The following arrays are required to be the same length. They are parallel arrays for the given chainId and should be ordered by the `l1Tokens` field.\\n        // All whitelisted tokens with nonzero relays on this chain in this bundle in the order of whitelisting.\\n        address[] l1Tokens;\\n    }\\n\\n    function setBond(IERC20 newBondToken, uint256 newBondAmount) external;\\n\\n    function setCrossChainContracts(\\n        uint256 l2ChainId,\\n        address adapter,\\n        address spokePool\\n    ) external;\\n\\n    function whitelistRoute(\\n        uint256 destinationChainId,\\n        address originToken,\\n        address destinationToken\\n    ) external;\\n\\n    function enableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function disableL1TokenForLiquidityProvision(address l1Token) external;\\n\\n    function addLiquidity(address l1Token, uint256 l1TokenAmount) external payable;\\n\\n    function removeLiquidity(\\n        address l1Token,\\n        uint256 lpTokenAmount,\\n        bool sendEth\\n    ) external;\\n\\n    function exchangeRateCurrent(address l1Token) external returns (uint256);\\n\\n    function liquidityUtilizationPostRelay(address token, uint256 relayedAmount) external returns (uint256);\\n\\n    function initiateRelayerRefund(\\n        uint256[] memory bundleEvaluationBlockNumbers,\\n        uint8 poolRebalanceLeafCount,\\n        bytes32 poolRebalanceRoot,\\n        bytes32 destinationDistributionRoot,\\n        bytes32 slowRelayFulfillmentRoot\\n    ) external;\\n\\n    function executeRelayerRefund(PoolRebalanceLeaf memory poolRebalanceLeaf, bytes32[] memory proof) external;\\n\\n    function disputeRelayerRefund() external;\\n}\\n\",\"keccak256\":\"0x97a6d5b2272a916a2c10b866a03393a7c8a46913f27f1490dc90a2377d4e4247\",\"license\":\"GPL-3.0-only\"},\"contracts/MerkleLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-3.0-only\\npragma solidity ^0.8.0;\\n\\nimport \\\"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\\\";\\nimport \\\"./SpokePoolInterface.sol\\\";\\nimport \\\"./HubPoolInterface.sol\\\";\\n\\n/**\\n * @notice Library to help with merkle roots, proofs, and claims.\\n */\\nlibrary MerkleLib {\\n    /**\\n     * @notice Verifies that a repayment is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param rebalance the rebalance struct.\\n     * @param proof the merkle proof.\\n     */\\n    function verifyPoolRebalance(\\n        bytes32 root,\\n        HubPoolInterface.PoolRebalanceLeaf memory rebalance,\\n        bytes32[] memory proof\\n    ) public pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(rebalance)));\\n    }\\n\\n    /**\\n     * @notice Verifies that a distribution is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param distribution the distribution struct.\\n     * @param proof the merkle proof.\\n     */\\n    function verifyRelayerDistribution(\\n        bytes32 root,\\n        SpokePoolInterface.DestinationDistributionLeaf memory distribution,\\n        bytes32[] memory proof\\n    ) public pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(distribution)));\\n    }\\n\\n    /**\\n     * @notice Verifies that a distribution is contained within a merkle root.\\n     * @param root the merkle root.\\n     * @param slowRelayFulfillment the relayData fulfullment struct.\\n     * @param proof the merkle proof.\\n     */\\n    function verifySlowRelayFulfillment(\\n        bytes32 root,\\n        SpokePoolInterface.RelayData memory slowRelayFulfillment,\\n        bytes32[] memory proof\\n    ) public pure returns (bool) {\\n        return MerkleProof.verify(proof, root, keccak256(abi.encode(slowRelayFulfillment)));\\n    }\\n\\n    // The following functions are primarily copied from\\n    // https://github.com/Uniswap/merkle-distributor/blob/master/contracts/MerkleDistributor.sol with minor changes.\\n\\n    /**\\n     * @notice Tests whether a claim is contained within a claimedBitMap mapping.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to check in the bitmap.\\n     * @return bool indicating if the index within the claimedBitMap has been marked as claimed.\\n     */\\n    function isClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) public view returns (bool) {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        uint256 claimedWord = claimedBitMap[claimedWordIndex];\\n        uint256 mask = (1 << claimedBitIndex);\\n        return claimedWord & mask == mask;\\n    }\\n\\n    /**\\n     * @notice Marks an index in a claimedBitMap as claimed.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to mark in the bitmap.\\n     */\\n    function setClaimed(mapping(uint256 => uint256) storage claimedBitMap, uint256 index) public {\\n        uint256 claimedWordIndex = index / 256;\\n        uint256 claimedBitIndex = index % 256;\\n        claimedBitMap[claimedWordIndex] = claimedBitMap[claimedWordIndex] | (1 << claimedBitIndex);\\n    }\\n\\n    /**\\n     * @notice Tests whether a claim is contained within a 1D claimedBitMap mapping.\\n     * @param claimedBitMap a simple uint256 value, encoding a 1D bitmap.\\n     * @param index the index to check in the bitmap.\\n     \\\\* @return bool indicating if the index within the claimedBitMap has been marked as claimed.\\n     */\\n    function isClaimed1D(uint256 claimedBitMap, uint256 index) public pure returns (bool) {\\n        uint256 mask = (1 << index);\\n        return claimedBitMap & mask == mask;\\n    }\\n\\n    /**\\n     * @notice Marks an index in a claimedBitMap as claimed.\\n     * @param claimedBitMap a simple uint256 mapping in storage used as a bitmap.\\n     * @param index the index to mark in the bitmap.\\n     */\\n    function setClaimed1D(uint256 claimedBitMap, uint256 index) public pure returns (uint256) {\\n        require(index <= 255, \\\"Index out of bounds\\\");\\n        return claimedBitMap | (1 << index % 256);\\n    }\\n}\\n\",\"keccak256\":\"0x3884b9b2db1cac358fbb333b975d0197e61083b35f20e18e9b18c91f15972ebe\",\"license\":\"GPL-3.0-only\"},\"contracts/SpokePoolInterface.sol\":{\"content\":\"//SPDX-License-Identifier: Unlicense\\npragma solidity ^0.8.0;\\n\\ninterface SpokePoolInterface {\\n    // This leaf is meant to be decoded in the SpokePool in order to pay out individual relayers for this bundle.\\n    struct DestinationDistributionLeaf {\\n        // This is the amount to return to the HubPool. This occurs when there is a PoolRebalanceLeaf netSendAmount that is\\n        // negative. This is just that value inverted.\\n        uint256 amountToReturn;\\n        // Used to verify that this is being decoded on the correct chainId.\\n        uint256 chainId;\\n        // This array designates how much each of those addresses should be refunded.\\n        uint256[] refundAmounts;\\n        // Used as the index in the bitmap to track whether this leaf has been executed or not.\\n        uint32 leafId;\\n        // The associated L2TokenAddress that these claims apply to.\\n        address l2TokenAddress;\\n        // These two arrays must be the same length and are parallel arrays. They should be order by refundAddresses.\\n        // This array designates each address that must be refunded.\\n        address[] refundAddresses;\\n    }\\n\\n    // This struct represents the data to fully-specify a relay. If any portion of this data differs, the relay is\\n    // considered to be completely distinct. Only one relay for a particular depositId, chainId pair should be\\n    // considered valid and repaid.\\n    struct RelayData {\\n        // The address that made the deposit on the origin chain.\\n        address depositor;\\n        // The recipient address on the destination chain.\\n        address recipient;\\n        // The corresponding token address on the destination chain.\\n        address destinationToken;\\n        // The total relay amount before fees are taken out.\\n        uint256 relayAmount;\\n        // Origin chain id.\\n        uint256 originChainId;\\n        // The LP Fee percentage computed by the relayer based on the deposit's quote timestamp\\n        // and the HubPool's utilization.\\n        uint64 realizedLpFeePct;\\n        // The relayer fee percentage specified in the deposit.\\n        uint64 relayerFeePct;\\n        // The id uniquely identifying this deposit on the origin chain.\\n        uint32 depositId;\\n    }\\n\\n    function setCrossDomainAdmin(address newCrossDomainAdmin) external;\\n\\n    function setHubPool(address newHubPool) external;\\n\\n    function setEnableRoute(\\n        address originToken,\\n        uint256 destinationChainId,\\n        bool enable\\n    ) external;\\n\\n    function setDepositQuoteTimeBuffer(uint32 buffer) external;\\n\\n    function initializeRelayerRefund(bytes32 relayerRepaymentDistributionRoot, bytes32 slowRelayRoot) external;\\n\\n    function distributeRelayerRefund(\\n        uint32 relayerRefundId,\\n        DestinationDistributionLeaf memory distributionLeaf,\\n        bytes32[] memory inclusionProof\\n    ) external;\\n}\\n\",\"keccak256\":\"0x20d6159d5b6a0b3f58f9e6bd2aa10bea3bda2ed25520b52dda28cbde26a9ad92\",\"license\":\"Unlicense\"},\"contracts/interfaces/AdapterInterface.sol\":{\"content\":\"// SPDX-License-Identifier: AGPL-3.0-only\\npragma solidity ^0.8.0;\\n\\n/**\\n * @notice Sends cross chain messages and tokens to contracts on a specific L2 network.\\n */\\n\\ninterface AdapterInterface {\\n    event HubPoolChanged(address newHubPool);\\n\\n    event MessageRelayed(address target, bytes message);\\n\\n    event TokensRelayed(address l1Token, address l2Token, uint256 amount, address to);\\n\\n    function relayMessage(address target, bytes memory message) external payable;\\n\\n    function relayTokens(\\n        address l1Token,\\n        address l2Token,\\n        uint256 amount,\\n        address to\\n    ) external payable;\\n}\\n\",\"keccak256\":\"0x60e1ed2205f90655fe4152a90709be15bc9550fb3faeaf9835fee22c095bab11\",\"license\":\"AGPL-3.0-only\"}},\"version\":1}",
  "bytecode": "0x610bfa61003a600b82828239805160001a60731461002d57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c8063837509b311610065578063837509b3146100fd578063b33f255014610110578063da1d404914610123578063e43b33e71461013657600080fd5b80631624b19a1461008c578063453db35b146100ae5780634e225326146100d4575b600080fd5b81801561009857600080fd5b506100ac6100a7366004610380565b610149565b005b6100c16100bc366004610380565b610187565b6040519081526020015b60405180910390f35b6100ed6100e2366004610380565b6001901b9081161490565b60405190151581526020016100cb565b6100ed61010b366004610598565b610212565b6100ed61011e366004610380565b61024d565b6100ed6101313660046106e6565b61028e565b6100ed6101443660046107dd565b6102a6565b6000610157610100836108ab565b90506000610167610100846108bf565b600092835260209490945250604090208054600190931b90921790915550565b600060ff8211156101f8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f496e646578206f7574206f6620626f756e647300000000000000000000000000604482015260640160405180910390fd5b610204610100836108bf565b6001901b8317905092915050565b600061024582858560405160200161022a9190610954565b604051602081830303815290604052805190602001206102be565b949350505050565b60008061025c610100846108ab565b9050600061026c610100856108bf565b6000928352602095909552506040902054600190931b92831690921492915050565b600061024582858560405160200161022a9190610a07565b600061024582858560405160200161022a9190610a9a565b6000826102cb85846102d4565b14949350505050565b600081815b84518110156103785760008582815181106102f6576102f6610b35565b60200260200101519050808311610338576040805160208101859052908101829052606001604051602081830303815290604052805190602001209250610365565b60408051602081018390529081018490526060016040516020818303038152906040528051906020012092505b508061037081610b64565b9150506102d9565b509392505050565b6000806040838503121561039357600080fd5b50508035926020909101359150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160c0810167ffffffffffffffff811182821017156103f4576103f46103a2565b60405290565b604051610100810167ffffffffffffffff811182821017156103f4576103f46103a2565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610465576104656103a2565b604052919050565b600067ffffffffffffffff821115610487576104876103a2565b5060051b60200190565b600082601f8301126104a257600080fd5b813560206104b76104b28361046d565b61041e565b82815260059290921b840181019181810190868411156104d657600080fd5b8286015b848110156104f157803583529183019183016104da565b509695505050505050565b803560ff8116811461050d57600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461050d57600080fd5b600082601f83011261054757600080fd5b813560206105576104b28361046d565b82815260059290921b8401810191818101908684111561057657600080fd5b8286015b848110156104f15761058b81610512565b835291830191830161057a565b6000806000606084860312156105ad57600080fd5b83359250602084013567ffffffffffffffff808211156105cc57600080fd5b9085019060c082880312156105e057600080fd5b6105e86103d1565b823581526020830135828111156105fe57600080fd5b61060a89828601610491565b60208301525060408301358281111561062257600080fd5b61062e89828601610491565b60408301525060608301358281111561064657600080fd5b61065289828601610491565b606083015250610664608084016104fc565b608082015260a08301358281111561067b57600080fd5b61068789828601610536565b60a083015250935060408601359150808211156106a357600080fd5b506106b086828701610491565b9150509250925092565b803567ffffffffffffffff8116811461050d57600080fd5b803563ffffffff8116811461050d57600080fd5b60008060008385036101408112156106fd57600080fd5b84359350610100807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08301121561073357600080fd5b61073b6103fa565b915061074960208701610512565b825261075760408701610512565b602083015261076860608701610512565b60408301526080860135606083015260a0860135608083015261078d60c087016106ba565b60a083015261079e60e087016106ba565b60c08301526107ae8187016106d2565b60e083015250915061012084013567ffffffffffffffff8111156107d157600080fd5b6106b086828701610491565b6000806000606084860312156107f257600080fd5b83359250602084013567ffffffffffffffff8082111561081157600080fd5b9085019060c0828803121561082557600080fd5b61082d6103d1565b823581526020830135602082015260408301358281111561084d57600080fd5b61085989828601610491565b60408301525061086b606084016106d2565b606082015261066460808401610512565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000826108ba576108ba61087c565b500490565b6000826108ce576108ce61087c565b500690565b600081518084526020808501945080840160005b83811015610903578151875295820195908201906001016108e7565b509495945050505050565b600081518084526020808501945080840160005b8381101561090357815173ffffffffffffffffffffffffffffffffffffffff1687529582019590820190600101610922565b60208152815160208201526000602083015160c0604084015261097a60e08401826108d3565b905060408401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0808584030160608601526109b683836108d3565b925060608601519150808584030160808601526109d383836108d3565b925060ff60808701511660a086015260a08601519150808584030160c0860152506109fe828261090e565b95945050505050565b60006101008201905073ffffffffffffffffffffffffffffffffffffffff80845116835280602085015116602084015280604085015116604084015250606083015160608301526080830151608083015260a083015167ffffffffffffffff80821660a08501528060c08601511660c0850152505060e0830151610a9360e084018263ffffffff169052565b5092915050565b6020815281516020820152602082015160408201526000604083015160c06060840152610aca60e08401826108d3565b905063ffffffff606085015116608084015273ffffffffffffffffffffffffffffffffffffffff60808501511660a084015260a08401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08483030160c08501526109fe828261090e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610bbd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506001019056fea26469706673582212207e7943b51c6da1956658f646e6b6110abade79acac991f2e45b276d3d5bd862f64736f6c634300080b0033",
  "deployedBytecode": "0x73000000000000000000000000000000000000000030146080604052600436106100875760003560e01c8063837509b311610065578063837509b3146100fd578063b33f255014610110578063da1d404914610123578063e43b33e71461013657600080fd5b80631624b19a1461008c578063453db35b146100ae5780634e225326146100d4575b600080fd5b81801561009857600080fd5b506100ac6100a7366004610380565b610149565b005b6100c16100bc366004610380565b610187565b6040519081526020015b60405180910390f35b6100ed6100e2366004610380565b6001901b9081161490565b60405190151581526020016100cb565b6100ed61010b366004610598565b610212565b6100ed61011e366004610380565b61024d565b6100ed6101313660046106e6565b61028e565b6100ed6101443660046107dd565b6102a6565b6000610157610100836108ab565b90506000610167610100846108bf565b600092835260209490945250604090208054600190931b90921790915550565b600060ff8211156101f8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601360248201527f496e646578206f7574206f6620626f756e647300000000000000000000000000604482015260640160405180910390fd5b610204610100836108bf565b6001901b8317905092915050565b600061024582858560405160200161022a9190610954565b604051602081830303815290604052805190602001206102be565b949350505050565b60008061025c610100846108ab565b9050600061026c610100856108bf565b6000928352602095909552506040902054600190931b92831690921492915050565b600061024582858560405160200161022a9190610a07565b600061024582858560405160200161022a9190610a9a565b6000826102cb85846102d4565b14949350505050565b600081815b84518110156103785760008582815181106102f6576102f6610b35565b60200260200101519050808311610338576040805160208101859052908101829052606001604051602081830303815290604052805190602001209250610365565b60408051602081018390529081018490526060016040516020818303038152906040528051906020012092505b508061037081610b64565b9150506102d9565b509392505050565b6000806040838503121561039357600080fd5b50508035926020909101359150565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b60405160c0810167ffffffffffffffff811182821017156103f4576103f46103a2565b60405290565b604051610100810167ffffffffffffffff811182821017156103f4576103f46103a2565b604051601f82017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016810167ffffffffffffffff81118282101715610465576104656103a2565b604052919050565b600067ffffffffffffffff821115610487576104876103a2565b5060051b60200190565b600082601f8301126104a257600080fd5b813560206104b76104b28361046d565b61041e565b82815260059290921b840181019181810190868411156104d657600080fd5b8286015b848110156104f157803583529183019183016104da565b509695505050505050565b803560ff8116811461050d57600080fd5b919050565b803573ffffffffffffffffffffffffffffffffffffffff8116811461050d57600080fd5b600082601f83011261054757600080fd5b813560206105576104b28361046d565b82815260059290921b8401810191818101908684111561057657600080fd5b8286015b848110156104f15761058b81610512565b835291830191830161057a565b6000806000606084860312156105ad57600080fd5b83359250602084013567ffffffffffffffff808211156105cc57600080fd5b9085019060c082880312156105e057600080fd5b6105e86103d1565b823581526020830135828111156105fe57600080fd5b61060a89828601610491565b60208301525060408301358281111561062257600080fd5b61062e89828601610491565b60408301525060608301358281111561064657600080fd5b61065289828601610491565b606083015250610664608084016104fc565b608082015260a08301358281111561067b57600080fd5b61068789828601610536565b60a083015250935060408601359150808211156106a357600080fd5b506106b086828701610491565b9150509250925092565b803567ffffffffffffffff8116811461050d57600080fd5b803563ffffffff8116811461050d57600080fd5b60008060008385036101408112156106fd57600080fd5b84359350610100807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08301121561073357600080fd5b61073b6103fa565b915061074960208701610512565b825261075760408701610512565b602083015261076860608701610512565b60408301526080860135606083015260a0860135608083015261078d60c087016106ba565b60a083015261079e60e087016106ba565b60c08301526107ae8187016106d2565b60e083015250915061012084013567ffffffffffffffff8111156107d157600080fd5b6106b086828701610491565b6000806000606084860312156107f257600080fd5b83359250602084013567ffffffffffffffff8082111561081157600080fd5b9085019060c0828803121561082557600080fd5b61082d6103d1565b823581526020830135602082015260408301358281111561084d57600080fd5b61085989828601610491565b60408301525061086b606084016106d2565b606082015261066460808401610512565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000826108ba576108ba61087c565b500490565b6000826108ce576108ce61087c565b500690565b600081518084526020808501945080840160005b83811015610903578151875295820195908201906001016108e7565b509495945050505050565b600081518084526020808501945080840160005b8381101561090357815173ffffffffffffffffffffffffffffffffffffffff1687529582019590820190600101610922565b60208152815160208201526000602083015160c0604084015261097a60e08401826108d3565b905060408401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0808584030160608601526109b683836108d3565b925060608601519150808584030160808601526109d383836108d3565b925060ff60808701511660a086015260a08601519150808584030160c0860152506109fe828261090e565b95945050505050565b60006101008201905073ffffffffffffffffffffffffffffffffffffffff80845116835280602085015116602084015280604085015116604084015250606083015160608301526080830151608083015260a083015167ffffffffffffffff80821660a08501528060c08601511660c0850152505060e0830151610a9360e084018263ffffffff169052565b5092915050565b6020815281516020820152602082015160408201526000604083015160c06060840152610aca60e08401826108d3565b905063ffffffff606085015116608084015273ffffffffffffffffffffffffffffffffffffffff60808501511660a084015260a08401517fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe08483030160c08501526109fe828261090e565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415610bbd577f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b506001019056fea26469706673582212207e7943b51c6da1956658f646e6b6110abade79acac991f2e45b276d3d5bd862f64736f6c634300080b0033",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "isClaimed(mapping(uint256 => uint256) storage,uint256)": {
        "params": {
          "claimedBitMap": "a simple uint256 mapping in storage used as a bitmap.",
          "index": "the index to check in the bitmap."
        },
        "returns": {
          "_0": "bool indicating if the index within the claimedBitMap has been marked as claimed."
        }
      },
      "isClaimed1D(uint256,uint256)": {
        "params": {
          "claimedBitMap": "a simple uint256 value, encoding a 1D bitmap.",
          "index": "the index to check in the bitmap."
        },
        "returns": {
          "_0": "bool indicating if the index within the claimedBitMap has been marked as claimed."
        }
      },
      "setClaimed(mapping(uint256 => uint256) storage,uint256)": {
        "params": {
          "claimedBitMap": "a simple uint256 mapping in storage used as a bitmap.",
          "index": "the index to mark in the bitmap."
        }
      },
      "setClaimed1D(uint256,uint256)": {
        "params": {
          "claimedBitMap": "a simple uint256 mapping in storage used as a bitmap.",
          "index": "the index to mark in the bitmap."
        }
      },
      "verifyPoolRebalance(bytes32,HubPoolInterface.PoolRebalanceLeaf,bytes32[])": {
        "params": {
          "proof": "the merkle proof.",
          "rebalance": "the rebalance struct.",
          "root": "the merkle root."
        }
      },
      "verifyRelayerDistribution(bytes32,SpokePoolInterface.DestinationDistributionLeaf,bytes32[])": {
        "params": {
          "distribution": "the distribution struct.",
          "proof": "the merkle proof.",
          "root": "the merkle root."
        }
      },
      "verifySlowRelayFulfillment(bytes32,SpokePoolInterface.RelayData,bytes32[])": {
        "params": {
          "proof": "the merkle proof.",
          "root": "the merkle root.",
          "slowRelayFulfillment": "the relayData fulfullment struct."
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "isClaimed(mapping(uint256 => uint256) storage,uint256)": {
        "notice": "Tests whether a claim is contained within a claimedBitMap mapping."
      },
      "isClaimed1D(uint256,uint256)": {
        "notice": "Tests whether a claim is contained within a 1D claimedBitMap mapping."
      },
      "setClaimed(mapping(uint256 => uint256) storage,uint256)": {
        "notice": "Marks an index in a claimedBitMap as claimed."
      },
      "setClaimed1D(uint256,uint256)": {
        "notice": "Marks an index in a claimedBitMap as claimed."
      },
      "verifyPoolRebalance(bytes32,HubPoolInterface.PoolRebalanceLeaf,bytes32[])": {
        "notice": "Verifies that a repayment is contained within a merkle root."
      },
      "verifyRelayerDistribution(bytes32,SpokePoolInterface.DestinationDistributionLeaf,bytes32[])": {
        "notice": "Verifies that a distribution is contained within a merkle root."
      },
      "verifySlowRelayFulfillment(bytes32,SpokePoolInterface.RelayData,bytes32[])": {
        "notice": "Verifies that a distribution is contained within a merkle root."
      }
    },
    "notice": "Library to help with merkle roots, proofs, and claims.",
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}
